@page "/streaming"
@rendermode @(new Microsoft.AspNetCore.Components.Web.InteractiveServerRenderMode())
@inject IJSRuntime JS
@inject NavigationManager Nav

<PageTitle>Streaming</PageTitle>

<div class="wrap">
    <h1>Streaming</h1>

    <div style="margin-top:20px">

    </div>

        <StreamControlPanel IsLive="@isLive" IsStreamPlaying="@isStreamPlaying" IsGoingLive="@isGoingLive"
        StreamerRunning="@streamerRunning" WaitingForIngestion="@waitingForIngestion" CameraEnabled="@(!cameraDisabled)"
        AutoBroadcastEnabled="@autoBroadcastEnabled" AutoUploadEnabled="@autoUploadEnabled" EndStreamAfterPrintEnabled="@endStreamAfterPrintEnabled" 
        EndStreamAfterSongEnabled="@endStreamAfterSongEnabled" BroadcastId="@(isLive ? broadcastId : null)"
        StatusMessage="@statusMessage" CurrentPrivacy="@currentPrivacy" OnGoLive="@GoLive" OnStopLive="@StopLive" OnToggleCamera="@ToggleCamera"
        AudioEnabled="@audioEnabled" OnAudioChanged="@OnAudioChanged"
        OnAutoBroadcastChanged="@OnAutoBroadcastChanged" OnAutoUploadChanged="@OnAutoUploadChanged" 
        OnEndStreamAfterPrintChanged="@OnEndStreamAfterPrintChanged" OnEndStreamAfterSongChanged="@OnEndStreamAfterSongChanged"
        MixProcessingEnabled="@mixProcessingEnabled" OnMixProcessingChanged="@((bool e) => OnMixProcessingChanged(e))"
        OverlayEnabled="@overlayEnabled" OnOverlayChanged="@((bool e) => OnOverlayChanged(e))" />

    <StreamContainer>
        <MjpegFeed />
        <OverlayMjpegFeed />
    </StreamContainer>

    <div style="margin-top:20px">
        <PrinterConsole Title="Printer Console" AllowSend="false" MaxLines="200" />
    </div>

    @if (!string.IsNullOrWhiteSpace(broadcastId) && isLive)
    {
        <div style="margin-top:20px">
            <h2 style="margin-bottom:10px">YouTube Live Stream</h2>
            <div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%;background:#000;border-radius:8px">
                <iframe 
                    src="https://www.youtube.com/embed/@broadcastId?autoplay=0&modestbranding=1" 
                    style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen>
                </iframe>
            </div>
        </div>
    }
</div>

<div id="toast-container"></div>

@code {
    private bool _jsReady = false;
    private List<(string Message, string Type)> _pendingToasts = new();
    private bool isLive = false;
    private bool isStreamPlaying = false;
    private bool isGoingLive = false;
    private bool streamerRunning = false;
    private bool waitingForIngestion = false;
    private string? broadcastId = null;
    private string? statusMessage = null;
    private string? currentPrivacy = null;
    private bool cameraDisabled = false;
    private bool autoBroadcastEnabled = false;
    private bool autoUploadEnabled = false;
    private bool endStreamAfterPrintEnabled = true;
    private bool endStreamAfterSongEnabled = false;
    private bool audioEnabled = false;
    private bool mixProcessingEnabled = true;
    private bool overlayEnabled = true;
    private List<TimelapseInfo>? timelapses = null;
    private HashSet<string> processingTimelapses = new();
    private Timer? refreshTimer;
    private Timer? _streamStatusTimer;
    private Timer? _liveStatusTimer;
    private bool _liveTimerFast = false;
    private static readonly TimeSpan _liveFastInterval = TimeSpan.FromMilliseconds(500);
    private static readonly TimeSpan _liveSlowInterval = TimeSpan.FromSeconds(30);

    protected override async Task OnInitializedAsync()
    {
        await CheckLiveStatus();
        await RefreshTimelapses();
        await RefreshCameraState();
        await RefreshConfigState();

        // Setup periodic refresh for non-live data (timelapse list)
        refreshTimer = new Timer(async _ =>
        {
            await InvokeAsync(async () =>
    {
            await RefreshTimelapses();
            StateHasChanged();
        });
        }, null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsReady = true;
            if (_pendingToasts.Count > 0)
            {
                foreach (var (msg, type) in _pendingToasts)
                {
                    try { await JS.InvokeVoidAsync("showToast", msg, type); } catch { }
                }
                _pendingToasts.Clear();
            }
            // Initialize MJPEG stream monitoring
            try { await JS.InvokeVoidAsync("initializeStreams"); } catch { }

            // Start periodic stream status check (with initial delay to ensure JS is loaded)
            _streamStatusTimer = new Timer(async _ =>
            {
                await InvokeAsync(async () =>
    {
                await CheckStreamStatus();
            });
            }, null, TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(2));

            // Start adaptive live-status polling so the Live button flips without manual refresh
            _liveStatusTimer = new Timer(async _ =>
            {
                await InvokeAsync(async () =>
    {
                    await CheckLiveStatus();
                });
            }, null, TimeSpan.FromSeconds(1), _liveSlowInterval);
            UpdateLiveStatusTimer();
        }
    }

    private async Task SafeToast(string message, string type = "info")
    {
        if (_jsReady)
        {
            try { await JS.InvokeVoidAsync("showToast", message, type); } catch { }
        }
        else
        {
            _pendingToasts.Add((message, type));
        }
    }

    private async Task SafeJsCall(string identifier, params object[] args)
    {
        if (_jsReady)
        {
            try { await JS.InvokeVoidAsync(identifier, args); } catch { }
        }
    }

    private async Task CheckStreamStatus()
    {
        if (!_jsReady) return;

        try
        {
            var playing = false;
            try
            {
                playing = await JS.InvokeAsync<bool>("getStreamPlayingStatus");
            }
            catch
            {
                // Fall back to server-side streamerRunning
                playing = false;
            }

            // If the backend ffmpeg streamer is running, treat that as "playing"
            if (!playing && streamerRunning)
            {
                playing = true;
            }

            if (playing != isStreamPlaying)
            {
                isStreamPlaying = playing;
                StateHasChanged();
            }
        }
        catch
        {
            // Silently ignore if JS function not yet available - will retry on next timer tick
        }
    }

    private async Task CheckLiveStatus()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.GetFromJsonAsync<LiveStatusResponse>("api/live/status");
            if (response != null)
            {
                isLive = response.IsLive;
                broadcastId = response.BroadcastId;
                streamerRunning = response.StreamerRunning;
                waitingForIngestion = response.WaitingForIngestion;
                currentPrivacy = response.Privacy;
                UpdateLiveStatusTimer();
            }

            // Also check end-after-song status
            if (isLive)
            {
                try
                {
                    var songResponse = await client.GetFromJsonAsync<EndAfterSongResponse>("api/stream/end-after-song");
                    if (songResponse != null)
                    {
                        endStreamAfterSongEnabled = songResponse.Enabled;
                    }
                }
                catch { }
            }
            else
            {
                // Reset when not live
                endStreamAfterSongEnabled = false;
            }
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore errors during live status check
        }
    }

    private async Task GoLive()
    {
        isGoingLive = true;
        statusMessage = "Starting live broadcast...";
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync("api/live/start", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                statusMessage = "Live broadcast started!";
                await SafeToast("Live broadcast started! Waiting for ingestion...", "success");
                await CheckLiveStatus();
                await Task.Delay(5000);
                statusMessage = null;
            }
            else
            {
                var errorMsg = result?.Error ?? "unknown error";
                statusMessage = $"Failed: {errorMsg}";
                await SafeToast($"Failed to start broadcast: {errorMsg}", "error");
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
            await SafeToast($"Error starting broadcast: {ex.Message}", "error");
        }
        finally
        {
            isGoingLive = false;
        }

        StateHasChanged();
    }

    private async Task StopLive()
    {
        statusMessage = "Stopping live broadcast...";
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync("api/live/stop", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                statusMessage = "Live broadcast stopped";
                await CheckLiveStatus();
                await Task.Delay(5000);
                statusMessage = null;
            }
            else
            {
                statusMessage = $"Failed to stop: {result?.Error ?? "unknown"}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
        }

        StateHasChanged();
    }

    private async Task RepairStream()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync("api/live/repair", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();
            if (result?.Success == true)
            {
                await SafeToast("Repair triggered", "success");
            }
            else
            {
                await SafeToast($"Repair failed: {result?.Error ?? "unknown"}", "error");
            }
            await Task.Delay(1500);
            await CheckLiveStatus();
        }
        catch (Exception ex)
        {
            await SafeToast($"Repair error: {ex.Message}", "error");
        }
    }

    private async Task ToggleCamera()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            await client.PostAsync("api/camera/toggle", null);
            await RefreshCameraState();
            await SafeJsCall("reloadStreams");
        }
        catch
        {
            // Silently ignore camera toggle errors
        }
    }

    private async Task RefreshCameraState()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.GetFromJsonAsync<CameraStateResponse>("api/camera");
            if (response != null)
            {
                cameraDisabled = response.Disabled;
            }
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore camera state query errors
        }
    }

    private async Task RefreshConfigState()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var configResponse = await client.GetFromJsonAsync<ConfigStateResponse>("api/config/state");
            if (configResponse != null)
            {
                autoBroadcastEnabled = configResponse.AutoBroadcastEnabled;
                autoUploadEnabled = configResponse.AutoUploadEnabled;
                endStreamAfterPrintEnabled = configResponse.EndStreamAfterPrintEnabled;
                // New: read audio feature flag so UI can reflect persistent setting
                try { audioEnabled = configResponse.AudioEnabled; } catch { audioEnabled = false; }
            }
            // Fetch mix processing state
            try
            {
                using var mixClient = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
                var mixResponse = await mixClient.GetFromJsonAsync<MixStateResponse>("api/stream/mix-enabled");
                if (mixResponse != null)
                {
                    mixProcessingEnabled = mixResponse.Enabled;
                }
            }
            catch { }
            
            // Fetch overlay state
            try
            {
                using var overlayClient = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
                var overlayResponse = await overlayClient.GetFromJsonAsync<OverlayStateResponse>("api/overlay/enabled");
                if (overlayResponse != null)
                {
                    overlayEnabled = overlayResponse.Enabled;
                }
            }
            catch { }
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore config state query errors
        }
    }

    private async Task OnAutoBroadcastChanged(bool enabled)
    {
        autoBroadcastEnabled = enabled;
        StateHasChanged();
        await SafeToast($"Auto-broadcast {(enabled ? "enabled" : "disabled")}", "success");
        await RefreshConfigState();
    }

    private async Task OnAudioChanged(bool enabled)
    {
        // Respond to the child component toggling audio; update UI and show a toast
        audioEnabled = enabled;
        StateHasChanged();
        await SafeToast($"Audio feed {(enabled ? "enabled" : "disabled")}", "success");
        // Make sure the backend config is refreshed
        await RefreshConfigState();
    }

    private async Task OnAutoUploadChanged(bool enabled)
    {
        autoUploadEnabled = enabled;
        StateHasChanged();
        await SafeToast($"Auto-upload {(enabled ? "enabled" : "disabled")}", "success");
        await RefreshConfigState();
    }

    private async Task OnEndStreamAfterPrintChanged(bool enabled)
    {
        endStreamAfterPrintEnabled = enabled;
        StateHasChanged();
        await SafeToast($"End stream after print {(enabled ? "enabled" : "disabled")}", "success");
        await RefreshConfigState();
    }

    private async Task OnEndStreamAfterSongChanged(bool enabled)
    {
        endStreamAfterSongEnabled = enabled;
        StateHasChanged();
        if (enabled)
        {
            await SafeToast("Stream will end after current song finishes", "info");
        }
        else
        {
            await SafeToast("End after song cancelled", "success");
        }
    }

    private async Task OnMixProcessingChanged(bool enabled)
    {
        mixProcessingEnabled = enabled;
        StateHasChanged();
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/stream/mix-enabled?enabled={enabled}", null);
            if (response.IsSuccessStatusCode)
            {
                await SafeToast($"Mix processing {(enabled ? "enabled" : "disabled")}", "success");
            }
            else
            {
                await SafeToast($"Failed to toggle mix processing", "error");
                mixProcessingEnabled = !enabled;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error toggling mix processing: {ex.Message}", "error");
            mixProcessingEnabled = !enabled;
            StateHasChanged();
        }
    }

    private async Task OnOverlayChanged(bool enabled)
    {
        overlayEnabled = enabled;
        StateHasChanged();
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/overlay/enabled?enabled={enabled}", null);
            if (response.IsSuccessStatusCode)
            {
                await SafeToast($"Overlay {(enabled ? "enabled" : "disabled")}", "success");
            }
            else
            {
                await SafeToast($"Failed to toggle overlay", "error");
                overlayEnabled = !enabled;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error toggling overlay: {ex.Message}", "error");
            overlayEnabled = !enabled;
            StateHasChanged();
        }
    }

    private async Task RefreshTimelapses()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            timelapses = await client.GetFromJsonAsync<List<TimelapseInfo>>("api/timelapses");
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore timelapse load errors
        }
    }

    private async Task StopTimelapse(string name)
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/stop", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Video created successfully!", "success");
            }
            else
            {
                await SafeToast($"Failed to stop timelapse: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error stopping timelapse: {ex.Message}", "error");
        }
    }

    private async Task GenerateTimelapse(string name)
    {
        processingTimelapses.Add(name);
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/generate", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Video generated successfully!", "success");
            }
            else
            {
                await SafeToast($"Failed to generate video: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error generating video: {ex.Message}", "error");
        }
        finally
        {
            processingTimelapses.Remove(name);
            StateHasChanged();
        }
    }

    private async Task RegenerateTimelapse(string name)
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/generate", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Video regenerated successfully!", "success");
            }
            else
            {
                await SafeToast($"Failed to regenerate video: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error regenerating video: {ex.Message}", "error");
        }
    }

    private async Task UploadTimelapse(string name)
    {
        processingTimelapses.Add(name);
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/upload", null);
            var jsonOptions = new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var result = await response.Content.ReadFromJsonAsync<UploadResponse>(jsonOptions);

            if (result?.Success == true)
            {
                await SafeToast($"Video uploaded successfully! {result.Url}", "success");
                await RefreshTimelapses(); // Refresh to show YouTube link
            }
            else
            {
                await SafeToast($"Failed to upload video: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error uploading video: {ex.Message}", "error");
        }
        finally
        {
            processingTimelapses.Remove(name);
            StateHasChanged();
        }
    }

    private async Task DeleteTimelapse(string name)
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.DeleteAsync($"api/timelapses/{Uri.EscapeDataString(name)}");
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Timelapse deleted successfully", "success");
            }
            else
            {
                await SafeToast($"Failed to delete timelapse: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error deleting timelapse: {ex.Message}", "error");
        }
    }

    private async Task DeleteAllTimelapses()
    {
        if (timelapses == null) return;

        var inactiveTimelapses = timelapses.Where(t => !t.IsActive).ToList();
        if (inactiveTimelapses.Count == 0)
        {
            await SafeToast("No inactive timelapses to delete", "info");
            return;
        }

        int deleted = 0;
        int failed = 0;

        foreach (var t in inactiveTimelapses)
        {
            try
            {
                using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
                var response = await client.DeleteAsync($"api/timelapses/{Uri.EscapeDataString(t.Name)}");
                var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

                if (result?.Success == true)
                    deleted++;
                else
                    failed++;
            }
            catch
            {
                failed++;
            }
        }

        await RefreshTimelapses();

        if (failed == 0)
            await SafeToast($"Successfully deleted {deleted} timelapse(s)", "success");
        else
            await SafeToast($"Deleted {deleted} timelapse(s), {failed} failed", "error");
    }

    public void Dispose()
    {
        refreshTimer?.Dispose();
        _streamStatusTimer?.Dispose();
        _liveStatusTimer?.Dispose();
    }

    // Response models
    private class LiveStatusResponse
    {
        public bool IsLive { get; set; }
        public string? BroadcastId { get; set; }
        public bool StreamerRunning { get; set; }
        public bool WaitingForIngestion { get; set; }
        public string? Privacy { get; set; }
    }

    private class ApiResponse
    {
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private class UploadResponse : ApiResponse
    {
        public string? Url { get; set; }
    }

    private class CameraStateResponse
    {
        public bool Disabled { get; set; }
    }

    private class EndAfterSongResponse
    {
        public bool Enabled { get; set; }
    }

    private class ConfigStateResponse
    {
        public bool AutoBroadcastEnabled { get; set; }
        public bool AutoUploadEnabled { get; set; }
        public bool EndStreamAfterPrintEnabled { get; set; }
        public bool AudioEnabled { get; set; }
    }

    private class MixStateResponse
    {
        public bool Enabled { get; set; }
    }

    private class OverlayStateResponse
    {
        public bool Enabled { get; set; }
    }

    // Adjust live-status polling frequency: fast while going live, slow when stable
    private void UpdateLiveStatusTimer()
    {
        try
        {
            if (_liveStatusTimer == null) return;
            var needFast = waitingForIngestion || (!isLive && streamerRunning);
            if (needFast != _liveTimerFast)
            {
                _liveTimerFast = needFast;
                var interval = needFast ? _liveFastInterval : _liveSlowInterval;
                _liveStatusTimer.Change(TimeSpan.FromMilliseconds(500), interval);
            }
        }
        catch { }
    }
}