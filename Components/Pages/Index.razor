@page "/"
@rendermode @(new Microsoft.AspNetCore.Components.Web.InteractiveServerRenderMode())
@inject IJSRuntime JS
@inject NavigationManager Nav

<PageTitle>PrintStreamer - Control Panel</PageTitle>

<div class="wrap">
    <h1>PrintStreamer - Control Panel</h1>

    <div style="margin-bottom:20px;padding:10px 0;border-bottom:1px solid #444">
        <NavLink href="/config" style="color:#66ccff;text-decoration:none;font-size:1.1em">‚öôÔ∏è Configuration</NavLink>
        <NavLink href="/timelapses" style="color:#66ccff;text-decoration:none;font-size:1.1em;margin-left:12px">üñºÔ∏è Manage Timelapses</NavLink>
        <NavLink href="/console" style="color:#66ccff;text-decoration:none;font-size:1.1em;margin-left:12px">üíª Console</NavLink>
    </div>
    <div style="margin-top:20px">

    </div>

        <StreamControlPanel IsLive="@isLive" IsStreamPlaying="@isStreamPlaying" IsGoingLive="@isGoingLive"
        StreamerRunning="@streamerRunning" WaitingForIngestion="@waitingForIngestion" CameraEnabled="@(!cameraDisabled)"
        AutoBroadcastEnabled="@autoBroadcastEnabled" AutoUploadEnabled="@autoUploadEnabled" BroadcastId="@broadcastId"
        StatusMessage="@statusMessage" OnGoLive="@GoLive" OnStopLive="@StopLive" OnToggleCamera="@ToggleCamera"
        OnAutoBroadcastChanged="@OnAutoBroadcastChanged" OnAutoUploadChanged="@OnAutoUploadChanged" />

    <StreamContainer>
        <MjpegFeed />
        <HlsFeed />
    </StreamContainer>

    @if (!string.IsNullOrWhiteSpace(broadcastId))
    {
        <div style="margin-top:20px">
            <h2 style="margin-bottom:10px">YouTube Live Stream</h2>
            <div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%;background:#000;border-radius:8px">
                <iframe 
                    src="https://www.youtube.com/embed/@broadcastId?autoplay=0&modestbranding=1" 
                    style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen>
                </iframe>
            </div>
        </div>
    }
</div>

<div id="toast-container"></div>

@code {
    private bool _jsReady = false;
    private List<(string Message, string Type)> _pendingToasts = new();
    private bool isLive = false;
    private bool isStreamPlaying = false;
    private bool isGoingLive = false;
    private bool streamerRunning = false;
    private bool waitingForIngestion = false;
    private string? broadcastId = null;
    private string? statusMessage = null;
    private bool cameraDisabled = false;
    private bool autoBroadcastEnabled = false;
    private bool autoUploadEnabled = false;
    private List<TimelapseInfo>? timelapses = null;
    private HashSet<string> processingTimelapses = new();
    private Timer? refreshTimer;
    private Timer? _streamStatusTimer;
    private Timer? _liveStatusTimer;
    private bool _liveTimerFast = false;
    private static readonly TimeSpan _liveFastInterval = TimeSpan.FromMilliseconds(500);
    private static readonly TimeSpan _liveSlowInterval = TimeSpan.FromSeconds(30);

    protected override async Task OnInitializedAsync()
    {
        await CheckLiveStatus();
        await RefreshTimelapses();
        await RefreshCameraState();
        await RefreshConfigState();

        // Setup periodic refresh for non-live data (timelapse list)
        refreshTimer = new Timer(async _ =>
        {
            await InvokeAsync(async () =>
    {
            await RefreshTimelapses();
            StateHasChanged();
        });
        }, null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsReady = true;
            if (_pendingToasts.Count > 0)
            {
                foreach (var (msg, type) in _pendingToasts)
                {
                    try { await JS.InvokeVoidAsync("showToast", msg, type); } catch { }
                }
                _pendingToasts.Clear();
            }
            // Initialize HLS player and MJPEG stream monitoring
            try { await JS.InvokeVoidAsync("initializeStreams"); } catch { }

            // Start periodic stream status check (with initial delay to ensure JS is loaded)
            _streamStatusTimer = new Timer(async _ =>
            {
                await InvokeAsync(async () =>
    {
                await CheckStreamStatus();
            });
            }, null, TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(2));

            // Start adaptive live-status polling so the Live button flips without manual refresh
            _liveStatusTimer = new Timer(async _ =>
            {
                await InvokeAsync(async () =>
    {
                    await CheckLiveStatus();
                });
            }, null, TimeSpan.FromSeconds(1), _liveSlowInterval);
            UpdateLiveStatusTimer();
        }
    }

    private async Task SafeToast(string message, string type = "info")
    {
        if (_jsReady)
        {
            try { await JS.InvokeVoidAsync("showToast", message, type); } catch { }
        }
        else
        {
            _pendingToasts.Add((message, type));
        }
    }

    private async Task SafeJsCall(string identifier, params object[] args)
    {
        if (_jsReady)
        {
            try { await JS.InvokeVoidAsync(identifier, args); } catch { }
        }
    }

    private async Task CheckStreamStatus()
    {
        if (!_jsReady) return;

        try
        {
            var playing = await JS.InvokeAsync<bool>("getStreamPlayingStatus");
            if (playing != isStreamPlaying)
            {
                isStreamPlaying = playing;
                StateHasChanged();
            }
        }
        catch
        {
            // Silently ignore if JS function not yet available - will retry on next timer tick
        }
    }

    private async Task CheckLiveStatus()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.GetFromJsonAsync<LiveStatusResponse>("api/live/status");
            if (response != null)
            {
                isLive = response.IsLive;
                broadcastId = response.BroadcastId;
                streamerRunning = response.StreamerRunning;
                waitingForIngestion = response.WaitingForIngestion;
                UpdateLiveStatusTimer();
            }
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore errors during live status check
        }
    }

    private async Task GoLive()
    {
        isGoingLive = true;
        statusMessage = "Starting live broadcast...";
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync("api/live/start", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                statusMessage = "Live broadcast started!";
                await CheckLiveStatus();
                await Task.Delay(5000);
                statusMessage = null;
            }
            else
            {
                statusMessage = $"Failed: {result?.Error ?? "unknown"}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isGoingLive = false;
        }

        StateHasChanged();
    }

    private async Task StopLive()
    {
        statusMessage = "Stopping live broadcast...";
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync("api/live/stop", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                statusMessage = "Live broadcast stopped";
                await CheckLiveStatus();
                await Task.Delay(5000);
                statusMessage = null;
            }
            else
            {
                statusMessage = $"Failed to stop: {result?.Error ?? "unknown"}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
        }

        StateHasChanged();
    }

    private async Task ToggleCamera()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            await client.PostAsync("api/camera/toggle", null);
            await RefreshCameraState();
            await SafeJsCall("reloadStreams");
        }
        catch
        {
            // Silently ignore camera toggle errors
        }
    }

    private async Task RefreshCameraState()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.GetFromJsonAsync<CameraStateResponse>("api/camera");
            if (response != null)
            {
                cameraDisabled = response.Disabled;
            }
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore camera state query errors
        }
    }

    private async Task RefreshConfigState()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var configResponse = await client.GetFromJsonAsync<ConfigStateResponse>("api/config/state");
            if (configResponse != null)
            {
                autoBroadcastEnabled = configResponse.AutoBroadcastEnabled;
                autoUploadEnabled = configResponse.AutoUploadEnabled;
            }
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore config state query errors
        }
    }

    private async Task OnAutoBroadcastChanged(bool enabled)
    {
        autoBroadcastEnabled = enabled;
        StateHasChanged();
        await SafeToast($"Auto-broadcast {(enabled ? "enabled" : "disabled")}", "success");
        await RefreshConfigState();
    }

    private async Task OnAutoUploadChanged(bool enabled)
    {
        autoUploadEnabled = enabled;
        StateHasChanged();
        await SafeToast($"Auto-upload {(enabled ? "enabled" : "disabled")}", "success");
        await RefreshConfigState();
    }

    private async Task RefreshTimelapses()
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            timelapses = await client.GetFromJsonAsync<List<TimelapseInfo>>("api/timelapses");
        }
        catch (HttpRequestException)
        {
            // Silently ignore connection errors (happens during shutdown)
        }
        catch (TaskCanceledException)
        {
            // Silently ignore cancellation (happens during shutdown)
        }
        catch
        {
            // Silently ignore timelapse load errors
        }
    }

    private async Task StopTimelapse(string name)
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/stop", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Video created successfully!", "success");
            }
            else
            {
                await SafeToast($"Failed to stop timelapse: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error stopping timelapse: {ex.Message}", "error");
        }
    }

    private async Task GenerateTimelapse(string name)
    {
        processingTimelapses.Add(name);
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/generate", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Video generated successfully!", "success");
            }
            else
            {
                await SafeToast($"Failed to generate video: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error generating video: {ex.Message}", "error");
        }
        finally
        {
            processingTimelapses.Remove(name);
            StateHasChanged();
        }
    }

    private async Task RegenerateTimelapse(string name)
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/generate", null);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Video regenerated successfully!", "success");
            }
            else
            {
                await SafeToast($"Failed to regenerate video: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error regenerating video: {ex.Message}", "error");
        }
    }

    private async Task UploadTimelapse(string name)
    {
        processingTimelapses.Add(name);
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/timelapses/{Uri.EscapeDataString(name)}/upload", null);
            var jsonOptions = new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var result = await response.Content.ReadFromJsonAsync<UploadResponse>(jsonOptions);

            if (result?.Success == true)
            {
                await SafeToast($"Video uploaded successfully! {result.Url}", "success");
                await RefreshTimelapses(); // Refresh to show YouTube link
            }
            else
            {
                await SafeToast($"Failed to upload video: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error uploading video: {ex.Message}", "error");
        }
        finally
        {
            processingTimelapses.Remove(name);
            StateHasChanged();
        }
    }

    private async Task DeleteTimelapse(string name)
    {
        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.DeleteAsync($"api/timelapses/{Uri.EscapeDataString(name)}");
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success == true)
            {
                await RefreshTimelapses();
                await SafeToast("Timelapse deleted successfully", "success");
            }
            else
            {
                await SafeToast($"Failed to delete timelapse: {result?.Error ?? "unknown"}", "error");
            }
        }
        catch (Exception ex)
        {
            await SafeToast($"Error deleting timelapse: {ex.Message}", "error");
        }
    }

    private async Task DeleteAllTimelapses()
    {
        if (timelapses == null) return;

        var inactiveTimelapses = timelapses.Where(t => !t.IsActive).ToList();
        if (inactiveTimelapses.Count == 0)
        {
            await SafeToast("No inactive timelapses to delete", "info");
            return;
        }

        int deleted = 0;
        int failed = 0;

        foreach (var t in inactiveTimelapses)
        {
            try
            {
                using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
                var response = await client.DeleteAsync($"api/timelapses/{Uri.EscapeDataString(t.Name)}");
                var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

                if (result?.Success == true)
                    deleted++;
                else
                    failed++;
            }
            catch
            {
                failed++;
            }
        }

        await RefreshTimelapses();

        if (failed == 0)
            await SafeToast($"Successfully deleted {deleted} timelapse(s)", "success");
        else
            await SafeToast($"Deleted {deleted} timelapse(s), {failed} failed", "error");
    }

    public void Dispose()
    {
        refreshTimer?.Dispose();
        _streamStatusTimer?.Dispose();
        _liveStatusTimer?.Dispose();
    }

    // Response models
    private class LiveStatusResponse
    {
        public bool IsLive { get; set; }
        public string? BroadcastId { get; set; }
        public bool StreamerRunning { get; set; }
        public bool WaitingForIngestion { get; set; }
    }

    private class ApiResponse
    {
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private class UploadResponse : ApiResponse
    {
        public string? Url { get; set; }
    }

    private class CameraStateResponse
    {
        public bool Disabled { get; set; }
    }

    private class ConfigStateResponse
    {
        public bool AutoBroadcastEnabled { get; set; }
        public bool AutoUploadEnabled { get; set; }
    }

    // Adjust live-status polling frequency: fast while going live, slow when stable
    private void UpdateLiveStatusTimer()
    {
        try
        {
            if (_liveStatusTimer == null) return;
            var needFast = waitingForIngestion || (!isLive && streamerRunning);
            if (needFast != _liveTimerFast)
            {
                _liveTimerFast = needFast;
                var interval = needFast ? _liveFastInterval : _liveSlowInterval;
                _liveStatusTimer.Change(TimeSpan.FromMilliseconds(500), interval);
            }
        }
        catch { }
    }
}