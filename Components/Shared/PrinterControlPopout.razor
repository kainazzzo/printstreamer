@using PrintStreamer.Services
@* Component needs InteractiveServer to handle button clicks and state changes *@
@rendermode @(new Microsoft.AspNetCore.Components.Web.InteractiveServerRenderMode())
@implements IAsyncDisposable
@inject PrinterConsoleService PrinterConsoleService
@inject IConfiguration Cfg
@inject IJSRuntime JS
@inject PrinterControlApiService PrinterApi

<style>
    .popout-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 400px;
        max-height: 95vh;
        height: 90vh;
        background: linear-gradient(135deg, #1a1a1a 0%, #252525 100%);
        border: 2px solid #00bfff;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(0, 191, 255, 0.05);
        display: flex;
        flex-direction: column;
        z-index: 9999;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
    }

    .popout-container.minimized {
        width: 60px;
        height: 60px;
        max-height: none;
    }

    .popout-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        border-bottom: 1px solid rgba(0, 191, 255, 0.3);
        background: linear-gradient(90deg, rgba(0, 100, 150, 0.3), rgba(0, 191, 255, 0.1));
        border-radius: 10px 10px 0 0;
        cursor: move;
    }

    .popout-header h3 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: #00bfff;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        flex: 1;
    }

    .popout-header-controls {
        display: flex;
        gap: 8px;
    }

    .popout-header button {
        background: transparent;
        border: none;
        color: #00bfff;
        cursor: pointer;
        padding: 6px 10px;
        font-size: 18px;
        font-weight: bold;
        transition: all 0.2s;
        border-radius: 4px;
        position: relative;
    }

    .popout-header button:hover {
        background: rgba(0, 191, 255, 0.3);
        color: #fff;
    }

    .popout-header button:active {
        transform: scale(0.95);
    }

    .popout-content {
        flex: 1;
        overflow: hidden;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 0;
    }

    .popout-container.minimized .popout-content {
        display: none;
    }

    .control-section {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(0, 191, 255, 0.2);
        border-radius: 8px;
        padding: 12px;
        flex-shrink: 0;
    }

    .control-section.console-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
    }

    .control-section h4 {
        margin: 0 0 8px 0;
        font-size: 11px;
        color: #00bfff;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 600;
    }

    .control-section.console-section h4 {
        margin: 0 0 6px 0;
    }

    .temperature-controls {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .temp-input-group {
        display: flex;
        gap: 6px;
        align-items: center;
        font-size: 11px;
    }

    .temp-input-group label {
        flex: 0 0 40px;
        font-size: 11px;
        color: #aaa;
        font-weight: 500;
    }

    .temp-input-group input {
        flex: 1;
        padding: 4px 6px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(0, 191, 255, 0.3);
        color: #fff;
        border-radius: 4px;
        font-family: monospace;
        font-size: 11px;
    }

    .temp-input-group button {
        padding: 4px 10px;
        background: rgba(0, 191, 255, 0.2);
        border: 1px solid rgba(0, 191, 255, 0.5);
        color: #00bfff;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        font-weight: 600;
        transition: all 0.2s;
    }

    .temp-input-group button:hover {
        background: rgba(0, 191, 255, 0.4);
        border-color: #00bfff;
    }

    .current-temp {
        flex: 0 0 auto;
        font-size: 1rem;
        color: #888;
        font-family: monospace;
        min-width: 40px;
        text-align: right;
    }

    .preset-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
    }

    .preset-btn {
        padding: 6px 10px;
        background: rgba(0, 191, 255, 0.15);
        border: 1px solid rgba(0, 191, 255, 0.4);
        color: #00bfff;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
        font-weight: 600;
        transition: all 0.2s;
    }

    .preset-btn:hover {
        background: rgba(0, 191, 255, 0.3);
        border-color: #00bfff;
        transform: translateY(-1px);
    }

    .preset-btn:active {
        transform: translateY(0);
    }

    .cancel-btn {
        width: 100%;
        padding: 8px 12px;
        background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(255, 107, 107, 0.1));
        border: 1px solid rgba(255, 107, 107, 0.5);
        color: #ff6b6b;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
        font-weight: 600;
        transition: all 0.2s;
        margin-top: 6px;
    }

    .cancel-btn:hover {
        background: linear-gradient(135deg, rgba(255, 107, 107, 0.5), rgba(255, 107, 107, 0.3));
        border-color: #ff6b6b;
        transform: translateY(-1px);
    }

    .cancel-btn:active {
        transform: translateY(0);
    }

    .gcode-send-section {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .gcode-input {
        display: flex;
        gap: 5px;
    }

    .gcode-input input {
        flex: 1;
        padding: 6px 8px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(0, 191, 255, 0.3);
        color: #fff;
        border-radius: 4px;
        font-family: monospace;
        font-size: 11px;
    }

    .gcode-input button {
        padding: 6px 12px;
        background: linear-gradient(135deg, rgba(0, 191, 255, 0.3), rgba(0, 191, 255, 0.1));
        border: 1px solid rgba(0, 191, 255, 0.6);
        color: #00bfff;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
        font-size: 11px;
        transition: all 0.2s;
    }

    .gcode-input button:hover {
        background: linear-gradient(135deg, rgba(0, 191, 255, 0.5), rgba(0, 191, 255, 0.3));
        border-color: #00bfff;
    }

    .popout-content::-webkit-scrollbar {
        width: 6px;
    }

    .popout-content::-webkit-scrollbar-track {
        background: rgba(0, 191, 255, 0.1);
        border-radius: 3px;
    }

    .popout-content::-webkit-scrollbar-thumb {
        background: rgba(0, 191, 255, 0.3);
        border-radius: 3px;
    }

    .popout-content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 191, 255, 0.5);
    }

    .console-output {
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(0, 191, 255, 0.2);
        border-radius: 6px;
        padding: 8px;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #aaa;
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .console-output .console-window {
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-height: 0;
        overscroll-behavior: contain;
    }
    .console-output .console-window.flipped {
        flex-direction: column-reverse;
    }

    .console-line {
        white-space: pre-wrap;
        word-break: break-word;
        line-height: 1.3;
    }

    .console-line.info {
        color: #aaa;
    }

    .console-line.error {
        color: #ff6b6b;
    }

    .console-line.warn {
        color: #ffd93d;
    }

    .console-controls {
        display: flex;
        gap: 5px;
        margin-top: 6px;
        padding-top: 5px;
        border-top: 1px solid rgba(0, 191, 255, 0.1);
        flex-shrink: 0;
    }

    .console-controls button {
        flex: 1;
        padding: 3px 6px;
        background: rgba(0, 191, 255, 0.15);
        border: 1px solid rgba(0, 191, 255, 0.3);
        color: #00bfff;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        font-weight: 600;
        transition: all 0.2s;
    }

    .console-controls button:hover {
        background: rgba(0, 191, 255, 0.3);
        border-color: #00bfff;
    }

    .console-controls button:active {
        transform: scale(0.95);
    }

    .console-controls button.active {
        background: rgba(0, 191, 255, 0.3);
        border-color: #00bfff;
        box-shadow: inset 0 0 8px rgba(0, 191, 255, 0.2);
    }
</style>

<div class="popout-container @(_minimized ? "minimized" : "")">
    <div class="popout-header" @onclick="HandleHeaderClick" style="@(_minimized ? "cursor: pointer;" : "")">
        @if (!_minimized)
        {
            <h3>üñ®Ô∏è PRINTER CONTROL</h3>
        }
        else
        {
            <h3 style="text-align: center; width: 100%; margin: 0; font-size: 24px;">üñ®Ô∏è</h3>
        }
        <div class="popout-header-controls" @onclick:stopPropagation="true">
            @if (!_minimized)
            {
                <button type="button" @onclick="ToggleMinimize" title="Minimize">‚àí</button>
            }
        </div>
    </div>

    @if (!_minimized)
    {
        <div class="popout-content">
            <div class="control-section">
                <h4>Temperature</h4>
                <div class="temperature-controls">
                    <div class="temp-input-group">
                        <label>Tool:</label>
                        <input type="number" @bind="_toolTemp" min="0" max="@_toolMaxTemp" />
                        <button @onclick="SetToolTemp">Set</button>
                        <span class="current-temp">@(_currentToolTemp?.ToString("F0") ?? "‚Äî")¬∞C</span>
                    </div>
                    <div class="temp-input-group">
                        <label>Bed:</label>
                        <input type="number" @bind="_bedTemp" min="0" max="@_bedMaxTemp" />
                        <button @onclick="SetBedTemp">Set</button>
                        <span class="current-temp">@(_currentBedTemp?.ToString("F0") ?? "‚Äî")¬∞C</span>
                    </div>
                    <div class="preset-buttons">
                        @if (_presets != null && _presets.Count > 0)
                        {
                            foreach (var p in _presets)
                            {
                                <button class="preset-btn" @onclick="() => ApplyPreset(p.Name)">@p.Name</button>
                            }
                        }
                        else
                        {
                            <button class="preset-btn" @onclick='() => ApplyPreset("pla")'>PLA</button>
                            <button class="preset-btn" @onclick='() => ApplyPreset("petg")'>PETG</button>
                            <button class="preset-btn" @onclick='() => ApplyPreset("abs")'>ABS</button>
                            <button class="preset-btn" @onclick='() => ApplyPreset("cooldown")'>Cooldown</button>
                        }
                    </div>
                    <div style="display:flex;gap:6px;flex-direction:column;align-items:stretch;">
                        <button class="cancel-btn" @onclick="ConfirmCancel" title="Cancel current print">üõë Cancel Print</button>
                        <button class="preset-btn" @onclick="ReprintLast" disabled="@(!_isErrorState || string.IsNullOrWhiteSpace(_reprintLastFileName) || _isReprintBusy)" title="Reprint last completed job">üîÅ Reprint</button>
                        @if (!string.IsNullOrWhiteSpace(_reprintLastFileName))
                        {
                            <div style="font-size:12px;color:#ccc;margin-top:6px;">Last/Current: @_reprintLastFileName</div>
                        }
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h4>Send G-Code</h4>
                <div class="gcode-send-section">
                    <div class="gcode-input">
                        <input type="text" @bind="_gcodeCommand" placeholder="Enter G-code..." @onkeydown="HandleGcodeKeydown" @ref="_gcodeInputRef" />
                        <button @onclick="SendGcode">Send</button>
                    </div>
                </div>
            </div>

            <div class="control-section console-section">
                <h4>Console</h4>
                    <div class="console-output">
                            <ConsoleDisplay @ref="_displayRef" Lines="GetDisplayConsoleLines()" ContainerId="popoutConsoleLines" AutoScroll="_autoScroll" FlipLayout="_consoleFlipped" Height="100%" />
                    </div>
                <div class="console-controls">
                    <button @onclick="ToggleAutoScroll" class="@(_autoScroll ? "active" : "")" title="Toggle auto-scroll">
                        @(_autoScroll ? "‚Üì" : "‚Üï") Auto
                    </button>
                    <button @onclick="ToggleConsoleFlip" class="@(_consoleFlipped ? "active" : "")" title="Flip layout">
                        ‚áÖ Flip
                    </button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private bool _minimized = true;
    private int _toolTemp = 200;
    private int _bedTemp = 60;
    private int _toolMaxTemp = 350;
    private int _bedMaxTemp = 120;
    private double? _currentToolTemp;
    private double? _currentBedTemp;
    private string _gcodeCommand = string.Empty;
    private bool _autoScroll = true;
    private bool _consoleFlipped = false;
    private List<ConsoleLine> _consoleLinesBuffer = new();
    private string? _reprintLastFileName = null;
    private bool _isPrinting = false;
    private bool _isPrintingInProgress = false;
    private bool _isErrorState = false;
    private bool _isReprintBusy = false;
    // removed _consoleContainer ElementReference - ConsoleDisplay manages container by id
    private ElementReference _gcodeInputRef;
    private bool _disposed = false;
    private CancellationTokenSource? _tempUpdateCts;
        private ConsoleDisplay? _displayRef;

    // Configurable cancel macro (falls back to M409)
    private string _cancelMacro = "M409";

    // Optional configured presets loaded from appsettings (Macros:Temperature:Presets)
    private record Preset(string Name, int ToolTemp, int BedTemp);
    private List<Preset> _presets = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        try
        {
            // Load cancel macro from config (Macros:CancelPrint) with fallback
            try
            {
                _cancelMacro = Cfg.GetValue<string>("Macros:CancelPrint") ?? _cancelMacro;
            }
            catch { }

            // First try to get limits from the server-side PrinterApi when available
            if (PrinterApi != null)
            {
                var config = await PrinterApi.GetConfigAsync();
                if (config != null)
                {
                    _toolMaxTemp = config.ToolMaxTemp;
                    _bedMaxTemp = config.BedMaxTemp;
                }
            }

            // Fallback to Macros:Temperature then legacy Stream:Console values
            _toolMaxTemp = _toolMaxTemp != 0
                ? _toolMaxTemp
                : Cfg.GetValue<int?>("Macros:Temperature:ToolMaxTemp")
                    ?? Cfg.GetValue<int?>("Stream:Console:ToolMaxTemp") ?? 350;

            _bedMaxTemp = _bedMaxTemp != 0
                ? _bedMaxTemp
                : Cfg.GetValue<int?>("Macros:Temperature:BedMaxTemp")
                    ?? Cfg.GetValue<int?>("Stream:Console:BedMaxTemp") ?? 120;

            // Load configured presets if present
            try
            {
                var section = Cfg.GetSection("Macros:Temperature:Presets");
                if (section.Exists())
                {
                    foreach (var child in section.GetChildren())
                    {
                        var name = child.GetValue<string>("Name") ?? child.Key ?? "Preset";
                        var tool = child.GetValue<int?>("ToolTemp") ?? child.GetValue<int?>("Tool") ?? 0;
                        var bed = child.GetValue<int?>("BedTemp") ?? child.GetValue<int?>("Bed") ?? 0;
                        _presets.Add(new Preset(name, tool, bed));
                    }
                }
            }
            catch { }

            // Subscribe to console service for new lines
            if (PrinterConsoleService != null)
            {
                PrinterConsoleService.OnNewLine += OnNewConsoleLine;
                // Load existing lines (keep up to 100 lines for scrollable history)
                var lines = PrinterConsoleService.GetLatestLines(100);
                _consoleLinesBuffer = new List<ConsoleLine>(lines);
            }

            // Start periodic temperature updates
            _tempUpdateCts = new CancellationTokenSource();
            _ = UpdateTemperaturesPeriodicAsync(_tempUpdateCts.Token);
                // Kick off a synchronous reprint info load first so the UI updates quickly
                try
                {
                    if (PrinterApi != null)
                    {
                        var info = await PrinterApi.GetReprintInfoAsync();
                        if (info != null)
                        {
                            _reprintLastFileName = info.LastCompletedFilename ?? info.CurrentFilename;
                            _isPrinting = info.IsPrinting;
                            _isPrintingInProgress = info.IsPrintingInProgress;
                            _isErrorState = info.IsError;
                        }
                    }
                }
                catch { }
                _ = UpdateReprintInfoPeriodicAsync(_tempUpdateCts.Token);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading printer config: {ex.Message}");
            _toolMaxTemp = Cfg.GetValue<int?>("Macros:Temperature:ToolMaxTemp") ?? Cfg.GetValue<int?>("Stream:Console:ToolMaxTemp") ?? 350;
            _bedMaxTemp = Cfg.GetValue<int?>("Macros:Temperature:BedMaxTemp") ?? Cfg.GetValue<int?>("Stream:Console:BedMaxTemp") ?? 120;
        }
    }

    private async Task UpdateTemperaturesPeriodicAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested && !_disposed)
        {
            try
            {
                await Task.Delay(2000, ct); // Update every 2 seconds
                if (ct.IsCancellationRequested || _disposed) break;
                
                // Get current temperatures from PrinterConsoleService (uses cached WebSocket data)
                try
                {
                    var (toolTemp, bedTemp) = PrinterConsoleService.GetCurrentTemperatures();
                    _currentToolTemp = toolTemp;
                    _currentBedTemp = bedTemp;
                    await InvokeAsync(StateHasChanged);
                }
                catch { }
            }
            catch (OperationCanceledException) { break; }
            catch { }
        }
    }

    private async Task UpdateReprintInfoPeriodicAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested && !_disposed)
        {
            try
            {
                await Task.Delay(3000, ct);
                if (ct.IsCancellationRequested || _disposed) break;
                try
                {
                    var info = await PrinterApi.GetReprintInfoAsync(ct);
                    if (info != null)
                    {
                        _reprintLastFileName = info.LastCompletedFilename ?? info.CurrentFilename;
                        _isPrinting = info.IsPrinting;
                        _isPrintingInProgress = info.IsPrintingInProgress;
                        _isErrorState = info.IsError;
                        await InvokeAsync(StateHasChanged);
                    }
                }
                catch { }
            }
            catch (OperationCanceledException) { break; }
            catch { }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Only attempt initial auto-scroll when the popout is expanded.
        if (firstRender && _autoScroll && !_minimized)
        {
            // Poll until the console element has a measurable scrollHeight (content rendered),
            // then scroll to the correct end. This prevents the initial-load 'stuck at top' issue.
            var tries = 0;
            const int maxTries = 20;
            while (tries < maxTries)
            {
                try
                {
                    var height = await JS.InvokeAsync<int>("getScrollHeightById", "popoutConsoleLines");
                    if (height > 0) break;
                }
                catch { }
                tries++;
                await Task.Delay(50);
            }

            // Give a tiny moment for final layout, then scroll to the proper end.
            await Task.Delay(10);
            await ScrollToBottomAsync();
        }
    }

    private void OnNewConsoleLine(ConsoleLine line)
    {
        if (_disposed) return;

        // Create a new list to avoid collection modified exceptions during render
        var newBuffer = new List<ConsoleLine>(_consoleLinesBuffer);
        newBuffer.Add(line);
        if (newBuffer.Count > 100)
        {
            newBuffer.RemoveAt(0);
        }
        _consoleLinesBuffer = newBuffer;
        
        InvokeAsync(async () =>
        {
            if (_disposed) return;
            StateHasChanged();
            if (_autoScroll)
            {
                await Task.Delay(10);
                if (!_minimized) await ScrollToBottomAsync();
            }
        });
    }

    private List<ConsoleLine> GetDisplayConsoleLines()
    {
        return _consoleLinesBuffer;
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("psScrollToPositionWithRetry", "popoutConsoleLines", _consoleFlipped ? "top" : "bottom", 6, 30);
        }
        catch { }
    }

    private async Task ToggleAutoScroll()
    {
        _autoScroll = !_autoScroll;
        StateHasChanged();

        // When enabling auto-scroll, immediately jump to the correct end depending on flip state
        if (_autoScroll)
        {
            await Task.Delay(10);
            await ScrollToBottomAsync();
            try { await JS.InvokeVoidAsync("psForceScroll", "popoutConsoleLines", _consoleFlipped ? "top" : "bottom", 120); } catch { }
        }
    }

    private async Task ToggleConsoleFlip()
    {
        _consoleFlipped = !_consoleFlipped;
        StateHasChanged();

        // If auto-scroll is enabled, adjust scroll to the appropriate end after flipping
        if (_autoScroll)
        {
            // Refresh watcher so the flip state and computed styles are correct
            try { if (_displayRef != null) await _displayRef.RefreshWatchAsync(); } catch { }
            await Task.Delay(150);
            await ScrollToBottomAsync();
            try { await JS.InvokeVoidAsync("psForceScroll", "popoutConsoleLines", _consoleFlipped ? "top" : "bottom", 120); } catch { }
        }
    }

    private async Task ToggleMinimize()
    {
        // Toggle minimized state
        _minimized = !_minimized;
        StateHasChanged();

        // If we just expanded and auto-scroll is enabled, ensure the console scrolls to the correct end.
        if (!_minimized && _autoScroll)
        {
            // Wait for the DOM to render the expanded content, then poll until the console has height.
            var tries = 0;
            const int maxTries = 20;
            while (tries < maxTries)
            {
                try
                {
                    var height = await JS.InvokeAsync<int>("getScrollHeightById", "popoutConsoleLines");
                    if (height > 0) break;
                }
                catch { }
                tries++;
                await Task.Delay(50);
            }

            await Task.Delay(10);
            await ScrollToBottomAsync();
        }
    }

    private async Task HandleHeaderClick()
    {
        // Only expand when minimized (clicking header)
        if (_minimized)
        {
            await ToggleMinimize();
        }
    }

    private void ToggleOpen()
    {
        _minimized = true;
        StateHasChanged();
    }

    private async Task SetToolTemp()
    {
        if (_toolTemp < 0 || _toolTemp > _toolMaxTemp)
        {
            await ShowToastAsync($"Tool temp out of range (0..{_toolMaxTemp})", "error");
            return;
        }
        try
        {
            var res = await PrinterApi.SetToolTemperatureAsync(_toolTemp);
            await ShowToastAsync(res?.Success ?? false ? $"Tool temp set to {_toolTemp}¬∞C" : res?.Error ?? "Unknown error", res?.Success ?? false ? "success" : "error");
        }
        catch (Exception ex)
        {
            await ShowToastAsync($"Error: {ex.Message}", "error");
        }
    }

    private async Task SetBedTemp()
    {
        if (_bedTemp < 0 || _bedTemp > _bedMaxTemp)
        {
            await ShowToastAsync($"Bed temp out of range (0..{_bedMaxTemp})", "error");
            return;
        }
        try
        {
            var res = await PrinterApi.SetBedTemperatureAsync(_bedTemp);
            await ShowToastAsync(res?.Success ?? false ? $"Bed temp set to {_bedTemp}¬∞C" : res?.Error ?? "Unknown error", res?.Success ?? false ? "success" : "error");
        }
        catch (Exception ex)
        {
            await ShowToastAsync($"Error: {ex.Message}", "error");
        }
    }

    private async Task ConfirmCancel()
    {
        try
        {
            // Use browser confirm dialog to ask for user confirmation before cancelling the print
            var ok = false;
            try
            {
                ok = await JS.InvokeAsync<bool>("confirm", "Are you sure you want to cancel the current print?");
            }
            catch { /* ignore JS errors and treat as cancelled */ }

            if (!ok) return;

            await CancelPrint();
        }
        catch { }
    }

    private async Task CancelPrint()
    {
        try
        {
            var cmd = _cancelMacro ?? "M409";
            var res = await PrinterApi.SendGcodeAsync(cmd);
            await ShowToastAsync(res?.Success ?? false ? "Print cancel sent" : res?.Error ?? "Failed to cancel print", res?.Success ?? false ? "success" : "error");
        }
        catch (Exception ex)
        {
            await ShowToastAsync($"Error: {ex.Message}", "error");
        }
    }

    private async Task ReprintLast()
    {
        if (string.IsNullOrWhiteSpace(_reprintLastFileName))
        {
            await ShowToastAsync("No previous job available to reprint", "warning");
            return;
        }
        if (!_isErrorState)
        {
            await ShowToastAsync("Printer is currently printing", "warning");
            return;
        }
        try
        {
            _isReprintBusy = true;
            StateHasChanged();
            var res = await PrinterApi.ReprintLastAsync();
            if (res?.Success ?? false)
            {
                await ShowToastAsync($"Reprint started: {_reprintLastFileName}", "success");
            }
            else
            {
                var err = res?.Error ?? res?.Message ?? "Failed to start reprint";
                await ShowToastAsync(err, "error");
            }
        }
        catch (Exception ex)
        {
            await ShowToastAsync($"Error: {ex.Message}", "error");
        }
        finally
        {
            _isReprintBusy = false;
            StateHasChanged();
        }
    }

    private async Task ApplyPreset(string presetName)
    {
        try
        {
            var res = await PrinterApi.ApplyPresetAsync(presetName);
            if (res?.Success ?? false)
            {
                // Update local inputs with returned temps when available
                if (res.ToolTemp.HasValue) _toolTemp = res.ToolTemp.Value;
                if (res.BedTemp.HasValue) _bedTemp = res.BedTemp.Value;

                await ShowToastAsync($"Preset applied: Tool {_toolTemp}¬∞C, Bed {_bedTemp}¬∞C", "success");
            }
            else
            {
                var errorMsg = res?.Error ?? "Failed to apply preset";
                // Check for rate limit errors
                if (errorMsg.Contains("429") || errorMsg.Contains("rate") || errorMsg.Contains("too many"))
                {
                    errorMsg = "Rate limit - wait a moment and try again";
                }
                await ShowToastAsync(errorMsg, "error");
            }
        }
        catch (Exception ex)
        {
            var errorMsg = ex.Message;
            if (errorMsg.Contains("429") || errorMsg.Contains("rate") || errorMsg.Contains("too many"))
            {
                errorMsg = "Rate limit - wait a moment and try again";
            }
            await ShowToastAsync($"Error: {errorMsg}", "error");
        }
    }

    private async Task SendGcode()
    {
        if (string.IsNullOrWhiteSpace(_gcodeCommand))
        {
            await ShowToastAsync("Enter a G-code command", "warning");
            return;
        }

        try
        {
            var res = await PrinterApi.SendGcodeAsync(_gcodeCommand);
            await ShowToastAsync(res?.Success ?? false ? $"Sent: {_gcodeCommand}" : res?.Error ?? "Unknown error", res?.Success ?? false ? "success" : "error");
            _gcodeCommand = string.Empty;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await ShowToastAsync($"Error: {ex.Message}", "error");
        }
    }

    private async Task HandleGcodeKeydown(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Key == "Enter")
        {
            await SendGcode();
        }
    }

    private async Task ShowToastAsync(string message, string type)
    {
        try
        {
            await JS.InvokeVoidAsync("showToast", message, type);
        }
        catch { }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        // Cancel temperature updates
        try { _tempUpdateCts?.Cancel(); } catch { }
        try { _tempUpdateCts?.Dispose(); } catch { }

        // Unsubscribe from console service
        if (PrinterConsoleService != null)
        {
            PrinterConsoleService.OnNewLine -= OnNewConsoleLine;
        }

        await ValueTask.CompletedTask;
    }
}
