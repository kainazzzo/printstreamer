@using PrintStreamer.Services
@using Microsoft.Extensions.Logging
@inject PrinterConsoleService PrinterConsoleService
@inject ILogger<MiniGcodeRenderer> Logger
@implements IDisposable

<style>
    .console-display {
        width: 100%;
        height: 200px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid rgba(0, 191, 255, 0.2);
        border-radius: 6px;
        overflow-y: auto;
        padding: 8px;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #00ff00;
        display: flex;
        flex-direction: column;
    }

    .console-line {
        margin: 2px 0;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .console-line.info {
        color: #00ff00;
    }

    .console-line.error {
        color: #ff6b6b;
    }

    .console-line.warn {
        color: #ffd93d;
    }

    .console-line.local {
        color: #00bfff;
    }

    .console-empty {
        color: #666;
        font-style: italic;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }
</style>

<div style="display:flex;gap:8px;align-items:flex-start;">
    <div style="flex: 1 1 50%;">
        <GcodePreview CanvasId="@_containerId" Commands="_gcodeCommands" FetchFromApi="true" MaxLines="50" Height="200px" Width="100%" />
    </div>
    <div style="width:220px;">
        @{
            var cid = $"mini-console-lines-{Guid.NewGuid():N}";
        }
        <ConsoleDisplay Lines="_consoleLines" ContainerId="cid" AutoScroll="true" FlipLayout="false" Height="200px" />
    </div>
</div>

@code {
    private List<ConsoleLine> _consoleLines = new();
    // ElementRef removed - ConsoleDisplay manages its own DOM container
    private string _containerId = $"mini-console-{Guid.NewGuid():N}";
    private List<string> _gcodeCommands = new();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        
        // Load initial console lines
        _consoleLines = PrinterConsoleService.GetLatestLines(50).ToList();
        
        // Subscribe to new lines
        PrinterConsoleService.OnNewLine += HandleNewLine;
    }

    private void HandleNewLine(ConsoleLine line)
    {
        try { Logger.LogDebug("MiniGcodeRenderer: HandleNewLine invoked - {Timestamp:O} {Level} {FromLocal} {Text}", line.Timestamp, line.Level, line.FromLocal, line.Text); } catch { }
        _ = InvokeAsync(() =>
        {
            if (_consoleLines == null) _consoleLines = new List<ConsoleLine>();
            // Insert at beginning if flipped, otherwise append
            var isFlipped = false; // this component is simple and doesn't expose flip; default to consistent append
            try { /* if we had a flip flag, we'd use it here */ } catch { }
            if (isFlipped) _consoleLines.Insert(0, line); else _consoleLines.Add(line);
            // Update gcode command cache
            _gcodeCommands = _consoleLines.Select(l => l.Text).ToList();
            
            // Keep only the last 50 lines (trim from the end if flipped, otherwise from the start)
            if (_consoleLines.Count > 50)
            {
                if (isFlipped) _consoleLines.RemoveRange(50, _consoleLines.Count - 50);
                else _consoleLines.RemoveAt(0);
            }
            
            StateHasChanged();
            
            // Auto-scroll is handled by ConsoleDisplay's JS watcher
        });
    }

    public void Dispose()
    {
        try 
        { 
            PrinterConsoleService.OnNewLine -= HandleNewLine; 
        } 
        catch { }
    }
}

