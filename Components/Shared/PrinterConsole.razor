@using PrintStreamer.Services
@using Microsoft.Extensions.Logging
@inject PrinterConsoleService PrinterConsoleService
@inject IConfiguration Cfg
@inject IJSRuntime JS
@inject PrinterControlApiService PrinterApi
@inject ILogger<PrinterConsole> Logger
@implements IDisposable

@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public IDictionary<string, object?>? AdditionalAttributes { get; set; }

    [Parameter]
    public bool Collapsed { get; set; } = false;

    [Parameter]
    public int MaxLines { get; set; } = 200;

    [Parameter]
    public bool AllowSend { get; set; } = false;

    [Parameter]
    public string? Title { get; set; } = "Printer Console";

    private List<ConsoleLine> _lines = new List<ConsoleLine>();
    private string _input = string.Empty;
    private string? _lastSendMessage;
    private bool _autoScroll = true;
    private bool _flipLayout = false;
    private string _containerId = $"printer-console-{Guid.NewGuid().ToString("N")}";
    private ConsoleDisplay? _displayRef;
    // Presets loaded from configuration (appsettings)
    private record Preset(string Name, int ToolTemp, int BedTemp);
    private List<Preset> _presets = new List<Preset>();
    private string? _reprintLastFileName;
    private bool _isPrinting = false;
    private bool _isPrintingInProgress = false;
    private bool _isErrorState = false;
    private bool _isReprintBusy = false;
    private CancellationTokenSource? _reprintInfoCts;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        // Default AllowSend from config if not specified by parent
        try
        {
            if (!this.AdditionalAttributes?.ContainsKey("AllowSend") ?? true)
            {
                var allowFromCfg = Cfg.GetValue<bool?>("Stream:Console:AllowSend");
                if (allowFromCfg.HasValue) AllowSend = allowFromCfg.Value;
            }
        }
        catch { }
        // Periodic refresh to update reprint button state
        try
        {
            _reprintInfoCts = new CancellationTokenSource();
            _ = UpdateReprintInfoPeriodicAsync(_reprintInfoCts.Token);
        }
        catch { }

        // Load quick-action presets from configuration.
        // Prefer Macros:Temperature:Presets (new), fallback to Stream:Console:Presets for compatibility.
        try
        {
            var section = Cfg.GetSection("Macros:Temperature:Presets");
            if (!section.Exists())
            {
                section = Cfg.GetSection("Stream:Console:Presets");
            }

            if (section.Exists())
            {
                foreach (var child in section.GetChildren())
                {
                    var name = child.GetValue<string>("Name") ?? child.Key ?? "Preset";
                    var tool = child.GetValue<int?>("ToolTemp") ?? child.GetValue<int?>("Tool") ?? 0;
                    var bed = child.GetValue<int?>("BedTemp") ?? child.GetValue<int?>("Bed") ?? 0;
                    _presets.Add(new Preset(name, tool, bed));
                }
            }
        }
        catch { }
        _lines = PrinterConsoleService.GetLatestLines(MaxLines).ToList();
        PrinterConsoleService.OnNewLine += HandleNewLine;
        try { Logger.LogDebug("PrinterConsole: Subscribed to PrinterConsoleService.OnNewLine (MaxLines={MaxLines})", MaxLines); } catch { }
        // Try to load reprint info (if PrinterApi is available)
        try
        {
            if (PrinterApi != null)
            {
                var info = await PrinterApi.GetReprintInfoAsync();
                if (info != null)
                {
                    _reprintLastFileName = info.LastCompletedFilename ?? info.CurrentFilename;
                    _isPrinting = info.IsPrinting;
                    _isPrintingInProgress = info.IsPrintingInProgress;
                    _isErrorState = info.IsError;
                }
            }
        }
        catch { }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            try { Logger.LogDebug("PrinterConsole: OnAfterRender (firstRender=true) - ConsoleDisplay will initialize JS watcher (autoScroll={AutoScroll}, flipLayout={FlipLayout})", _autoScroll, _flipLayout); } catch { }
        }
    }

    private async Task OnAutoScrollChanged()
    {
        StateHasChanged();
        try { if (_displayRef != null) await _displayRef.RefreshWatchAsync(); } catch { }
    }

    private void HandleNewLine(ConsoleLine l)
    {
        try { Logger.LogDebug("PrinterConsole: HandleNewLine invoked - {Timestamp:O} {Level} {FromLocal} {Text}", l.Timestamp, l.Level, l.FromLocal, l.Text); } catch { }
        try { JS.InvokeVoidAsync("console.log", $"PrinterConsole: HandleNewLine - {l.Timestamp:O} {l.Level} {l.FromLocal} {l.Text}"); } catch { }
        // Update copy and trim - make a new list to avoid collection modified exceptions
        var newLines = new List<ConsoleLine>(_lines);
        newLines.Add(l);
        if (newLines.Count > MaxLines) newLines.RemoveRange(0, newLines.Count - MaxLines);
        _lines = newLines;
        // Safe UI update and auto-scroll
        _ = InvokeAsync(async () =>
        {
            try { Logger.LogDebug("PrinterConsole: InvokeAsync StateHasChanged (autoScroll={AutoScroll}, flipLayout={FlipLayout})", _autoScroll, _flipLayout); } catch { }
            StateHasChanged();
            if (_autoScroll)
            {
                try
                {
                if (_flipLayout)
                {
                    // Match popout behavior: small delay then call the simple scroll helper
                    await Task.Delay(10);
                    try { Logger.LogDebug("PrinterConsole: scrolling top (flip)"); } catch { }
                    try { await JS.InvokeVoidAsync("psScrollToPositionWithRetry", _containerId, "top", 6, 30); } catch { }
                }
                else
                {
                    await Task.Delay(10);
                    try { Logger.LogDebug("PrinterConsole: scrolling bottom"); } catch { }
                    try { await JS.InvokeVoidAsync("psScrollToPositionWithRetry", _containerId, "bottom", 6, 30); } catch { }
                }
                }
                catch { }
            }
        });
    }

    private async Task OnFlipChanged()
    {
        try { Logger.LogDebug("PrinterConsole: OnFlipChanged invoked - _flipLayout={FlipLayout} _autoScroll={AutoScroll}", _flipLayout, _autoScroll); } catch { }
        // Unregister watcher temporarily so we can re-register after the DOM flips
        try { await JS.InvokeVoidAsync("psUnwatchConsole", _containerId); } catch { }

        // Request a render first so the DOM order updates
        await InvokeAsync(StateHasChanged);

        // Small delay to ensure DOM is updated before measuring/scrolling.
        // Use the retry JS helper to handle asynchronous DOM updates and ensure correct end is visible.
        if (_autoScroll)
        {
            try
            {
                await Task.Delay(150);
                    if (_flipLayout)
                        {
                            await Task.Delay(40);
                        // Re-register watcher with updated flip state and computed style
                        try { if (_displayRef != null) await _displayRef.RefreshWatchAsync(); } catch { }
                            try { await JS.InvokeVoidAsync("psScrollToPositionWithRetry", _containerId, "top", 6, 30); } catch { }
                            // Force final position to avoid observer race
                            try { await JS.InvokeVoidAsync("psForceScroll", _containerId, "top", 120); } catch { }
                        }
                    else
                    {
                        await Task.Delay(40);
                        // Re-register watcher with updated flip setting
                        try { if (_displayRef != null) await _displayRef.RefreshWatchAsync(); } catch { }
                        try { await JS.InvokeVoidAsync("psScrollToPositionWithRetry", _containerId, "bottom", 6, 30); } catch { }
                        try { await JS.InvokeVoidAsync("psForceScroll", _containerId, "bottom", 120); } catch { }
                    }
                // Re-register watcher is handled by the shared ConsoleDisplay
                try { Logger.LogDebug("PrinterConsole: OnFlipChanged re-registered psWatchConsole (flip={FlipLayout}, autoScroll={AutoScroll})", _flipLayout, _autoScroll); } catch { }
                // Log computed style to help validate flip behavior
                try { var flexDir = await JS.InvokeAsync<string?>("getComputedStylePropertyById", _containerId, "flexDirection"); try { Logger.LogDebug("PrinterConsole: After flip - computed flexDirection={FlexDir}", flexDir); } catch { } } catch { }
            }
            catch { }
        }
        else
        {
            // Re-register watcher even when auto-scroll is disabled so flip toggles remain consistent
            // Re-register handled by the shared ConsoleDisplay
        }
    }

    public void Dispose()
    {
        try { PrinterConsoleService.OnNewLine -= HandleNewLine; } catch { }
        try { Logger.LogDebug("PrinterConsole: Unsubscribed from PrinterConsoleService.OnNewLine and disposed"); } catch { }
        try { _reprintInfoCts?.Cancel(); } catch { }
        try { _reprintInfoCts?.Dispose(); } catch { }
    }

    private async Task UpdateReprintInfoPeriodicAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(3000, ct);
                if (ct.IsCancellationRequested) break;
                try
                {
                    if (PrinterApi != null)
                    {
                        var info = await PrinterApi.GetReprintInfoAsync(ct);
                        if (info != null)
                        {
                            _reprintLastFileName = info.LastCompletedFilename ?? info.CurrentFilename;
                            _isPrinting = info.IsPrinting;
                            _isPrintingInProgress = info.IsPrintingInProgress;
                            await InvokeAsync(StateHasChanged);
                        }
                    }
                }
                catch { }
            }
            catch (OperationCanceledException) { break; }
            catch { }
        }
    }

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input)) return;
        var res = await PrinterConsoleService.SendCommandAsync(_input);
        _lastSendMessage = res.Message;
        _input = string.Empty;
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task ReprintLastConsole()
    {
        if (string.IsNullOrWhiteSpace(_reprintLastFileName))
        {
            try { await JS.InvokeVoidAsync("showToast", "No previous job available to reprint", "warning"); } catch { }
            return;
        }
        if (!_isErrorState)
        {
            try { await JS.InvokeVoidAsync("showToast", "Printer is currently printing", "warning"); } catch { }
            return;
        }
        try
        {
            _isReprintBusy = true;
            StateHasChanged();
            var res = await PrinterApi.ReprintLastAsync();
            if (res?.Success ?? false)
            {
                try { await JS.InvokeVoidAsync("showToast", $"Reprint started: {_reprintLastFileName}", "success"); } catch { }
            }
            else
            {
                var err = res?.Error ?? res?.Message ?? "Failed to start reprint";
                try { await JS.InvokeVoidAsync("showToast", err, "error"); } catch { }
            }
        }
        catch (Exception ex)
        {
            try { await JS.InvokeVoidAsync("showToast", $"Error: {ex.Message}", "error"); } catch { }
        }
        finally
        {
            _isReprintBusy = false;
            StateHasChanged();
        }
    }
}

<div class="printer-console">
    <div style="display:flex;align-items:center;gap:8px;">
        <h4 style="margin:0;">@Title</h4>
        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#888;">
            <input type="checkbox" @bind="_autoScroll" @bind:after="OnAutoScrollChanged" /> auto-scroll
        </label>
        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#888;">
            <input type="checkbox" @bind="_flipLayout" @bind:after="OnFlipChanged" /> flip layout
        </label>
    </div>
    @if (!Collapsed)
    {
        <ConsoleDisplay @ref="_displayRef" Lines="_lines" ContainerId="_containerId" AutoScroll="_autoScroll" FlipLayout="_flipLayout" Height="200px" />
        @if (AllowSend)
        {
            <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                <input @bind="_input" style="flex:1;padding:6px;font-family:monospace;" />
                <button @onclick="Send">Send</button>
                <button @onclick="ReprintLastConsole" disabled="@(_isPrintingInProgress || string.IsNullOrWhiteSpace(_reprintLastFileName) || _isReprintBusy)" title="Reprint last completed job">üîÅ</button>
            </div>
            <div style="margin-top:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                <span style="font-size:12px;color:#aaa;">Quick actions:</span>
                @if (_presets != null && _presets.Count > 0)
                {
                    foreach (var p in _presets)
                    {
                        <button @onclick="() => SendPreset(p.ToolTemp, p.BedTemp)">@p.Name</button>
                    }
                }
                else
                {
                    <!-- Fallback to original hard-coded presets when no configuration is present -->
                    <button @onclick="() => SendPreset(200,60)">PLA</button>
                    <button @onclick="() => SendPreset(240,70)">PETG</button>
                    <button @onclick="() => SendPreset(250,100)">ABS</button>
                    <button @onclick="() => SendPreset(0,0)">Cooldown</button>
                }
            </div>
            @if (!string.IsNullOrEmpty(_lastSendMessage))
            {
                    <div style="margin-top:6px;font-size:12px;color:#ccc;">@_lastSendMessage</div>
                    @if (!string.IsNullOrWhiteSpace(_reprintLastFileName))
                    {
                        <div style="margin-top:6px;font-size:12px;color:#ccc;">Last/Current: @_reprintLastFileName</div>
                    }
            }
        }
    }
</div>

@code {
    private async Task SendPreset(int toolTemp, int bedTemp)
    {
        var res = await PrinterConsoleService.SetTemperaturesAsync(toolTemp, bedTemp);
        _lastSendMessage = res.Message;
        _ = InvokeAsync(StateHasChanged);
    }
}
