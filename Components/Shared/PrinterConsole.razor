@using PrintStreamer.Services
@inject PrinterConsoleService PrinterConsoleService
@inject IConfiguration Cfg
@inject IJSRuntime JS

@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public IDictionary<string, object?>? AdditionalAttributes { get; set; }

    [Parameter]
    public bool Collapsed { get; set; } = false;

    [Parameter]
    public int MaxLines { get; set; } = 200;

    [Parameter]
    public bool AllowSend { get; set; } = false;

    [Parameter]
    public string? Title { get; set; } = "Printer Console";

    private List<ConsoleLine> _lines = new List<ConsoleLine>();
    private string _input = string.Empty;
    private string? _lastSendMessage;
    private bool _autoScroll = true;
    private bool _flipLayout = false;
    private string _containerId = $"printer-console-{Guid.NewGuid().ToString("N")}";
    // Presets loaded from configuration (appsettings)
    private record Preset(string Name, int ToolTemp, int BedTemp);
    private List<Preset> _presets = new List<Preset>();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Default AllowSend from config if not specified by parent
        try
        {
            if (!this.AdditionalAttributes?.ContainsKey("AllowSend") ?? true)
            {
                var allowFromCfg = Cfg.GetValue<bool?>("Stream:Console:AllowSend");
                if (allowFromCfg.HasValue) AllowSend = allowFromCfg.Value;
            }
        }
        catch { }

        // Load quick-action presets from configuration.
        // Prefer Macros:Temperature:Presets (new), fallback to Stream:Console:Presets for compatibility.
        try
        {
            var section = Cfg.GetSection("Macros:Temperature:Presets");
            if (!section.Exists())
            {
                section = Cfg.GetSection("Stream:Console:Presets");
            }

            if (section.Exists())
            {
                foreach (var child in section.GetChildren())
                {
                    var name = child.GetValue<string>("Name") ?? child.Key ?? "Preset";
                    var tool = child.GetValue<int?>("ToolTemp") ?? child.GetValue<int?>("Tool") ?? 0;
                    var bed = child.GetValue<int?>("BedTemp") ?? child.GetValue<int?>("Bed") ?? 0;
                    _presets.Add(new Preset(name, tool, bed));
                }
            }
        }
        catch { }
        _lines = PrinterConsoleService.GetLatestLines(MaxLines).ToList();
        PrinterConsoleService.OnNewLine += HandleNewLine;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            try { await JS.InvokeVoidAsync("psWatchConsole", _containerId, _autoScroll, _flipLayout); } catch { }
        }
    }

    private async Task OnAutoScrollChanged()
    {
        StateHasChanged();
        try { await JS.InvokeVoidAsync("psUpdateWatch", _containerId, _autoScroll, _flipLayout); } catch { }
    }

    private void HandleNewLine(ConsoleLine l)
    {
        // Update copy and trim - make a new list to avoid collection modified exceptions
        var newLines = new List<ConsoleLine>(_lines);
        newLines.Add(l);
        if (newLines.Count > MaxLines) newLines.RemoveRange(0, newLines.Count - MaxLines);
        _lines = newLines;
        // Safe UI update and auto-scroll
        _ = InvokeAsync(async () =>
        {
            StateHasChanged();
            if (_autoScroll)
            {
                try
                {
                if (_flipLayout)
                {
                    // Match popout behavior: small delay then call the simple scroll helper
                    await Task.Delay(10);
                    try { await JS.InvokeVoidAsync("scrollToPositionById", _containerId, "top"); } catch { }
                }
                else
                {
                    await Task.Delay(10);
                    try { await JS.InvokeVoidAsync("scrollToPositionById", _containerId, "bottom"); } catch { }
                }
                }
                catch { }
            }
        });
    }

    private async Task OnFlipChanged()
    {
        // Unregister watcher temporarily to avoid race where observer scrolls during DOM reorder
        try { await JS.InvokeVoidAsync("psUnwatchConsole", _containerId); } catch { }

        // Update watcher state immediately (kept for compatibility but observer is currently removed)
        try { await JS.InvokeVoidAsync("psUpdateWatch", _containerId, _autoScroll, _flipLayout); } catch { }

        // Request a render first so the DOM order updates
        await InvokeAsync(StateHasChanged);

        // Small delay to ensure DOM is updated before measuring/scrolling.
        // Use the retry JS helper to handle asynchronous DOM updates and ensure correct end is visible.
        if (_autoScroll)
        {
            try
            {
                await Task.Delay(40);
                if (_flipLayout)
                {
                    await Task.Delay(10);
                    try { await JS.InvokeVoidAsync("scrollToPositionById", _containerId, "top"); } catch { }
                }
                else
                {
                    await Task.Delay(10);
                    try { await JS.InvokeVoidAsync("scrollToPositionById", _containerId, "bottom"); } catch { }
                }
                // Re-register watcher with correct settings so future mutations are observed
                try { await JS.InvokeVoidAsync("psWatchConsole", _containerId, _autoScroll, _flipLayout); } catch { }
            }
            catch { }
        }
        else
        {
            // Re-register watcher even when auto-scroll is disabled so flip toggles remain consistent
            try { await JS.InvokeVoidAsync("psWatchConsole", _containerId, _autoScroll, _flipLayout); } catch { }
        }
    }

    public void Dispose()
    {
        try { PrinterConsoleService.OnNewLine -= HandleNewLine; } catch { }
    }

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input)) return;
        var res = await PrinterConsoleService.SendCommandAsync(_input);
        _lastSendMessage = res.Message;
        _input = string.Empty;
        _ = InvokeAsync(StateHasChanged);
    }
}

<div class="printer-console">
    <div style="display:flex;align-items:center;gap:8px;">
        <h4 style="margin:0;">@Title</h4>
        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#888;">
            <input type="checkbox" @bind="_autoScroll" @bind:after="OnAutoScrollChanged" /> auto-scroll
        </label>
        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#888;">
            <input type="checkbox" @bind="_flipLayout" @bind:after="OnFlipChanged" /> flip layout
        </label>
    </div>
    @if (!Collapsed)
    {
        <div id="@_containerId" data-flip="@(_flipLayout ? "true" : "false")" class="console-window @( _flipLayout ? "flipped" : "")" style="height:200px;overflow:auto;display:flex;flex-direction:column;background:#000;color:#fff;padding:8px;font-family:monospace;font-size:12px;white-space:pre-wrap;">
            @foreach (var line in _lines)
            {
                var color = line.Level switch
                {
                    "error" => "#ff6b6b",
                    "warn" => "#ffd93d",
                    "info" => "#6bcf7f",
                    _ => "#ccc"
                };
                var prefix = line.FromLocal ? "[local]" : "";
                <div style="color:@color">@(line.Timestamp.ToLocalTime().ToString("HH:mm:ss")) @prefix @line.Text</div>
            }
        </div>
        @if (AllowSend)
        {
            <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                <input @bind="_input" style="flex:1;padding:6px;font-family:monospace;" />
                <button @onclick="Send">Send</button>
            </div>
            <div style="margin-top:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                <span style="font-size:12px;color:#aaa;">Quick actions:</span>
                @if (_presets != null && _presets.Count > 0)
                {
                    foreach (var p in _presets)
                    {
                        <button @onclick="() => SendPreset(p.ToolTemp, p.BedTemp)">@p.Name</button>
                    }
                }
                else
                {
                    <!-- Fallback to original hard-coded presets when no configuration is present -->
                    <button @onclick="() => SendPreset(200,60)">PLA</button>
                    <button @onclick="() => SendPreset(240,70)">PETG</button>
                    <button @onclick="() => SendPreset(250,100)">ABS</button>
                    <button @onclick="() => SendPreset(0,0)">Cooldown</button>
                }
            </div>
            @if (!string.IsNullOrEmpty(_lastSendMessage))
            {
                <div style="margin-top:6px;font-size:12px;color:#ccc;">@_lastSendMessage</div>
            }
        }
    }
</div>

@code {
    private async Task SendPreset(int toolTemp, int bedTemp)
    {
        var res = await PrinterConsoleService.SetTemperaturesAsync(toolTemp, bedTemp);
        _lastSendMessage = res.Message;
        _ = InvokeAsync(StateHasChanged);
    }
}
