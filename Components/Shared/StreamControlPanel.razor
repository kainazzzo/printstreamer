@inject NavigationManager Nav
@inject ILogger<StreamControlPanel> Logger

<div class="control-panel">
    <!-- Control Buttons with Status -->
    <div class="controls">
        <!-- Camera Toggle Button -->
        <!-- Camera Toggle Button -->
        <button class="btn @(CameraEnabled ? "btn-danger" : "btn-success")" @onclick="ToggleCameraClicked"
            disabled="@(IsCameraBusy)" aria-busy="@(IsCameraBusy)" @onmouseover="OnCameraMouseOver"
            @onmouseout="OnCameraMouseOut">
            @if (CameraHover)
            {
                @if (IsCameraBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üìπ</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Source</span>
                    <span class="btn-status">@(CameraEnabled ? "Turn Off" : "Turn On")</span>
                </span>
            }
            else
            {
                @if (IsCameraBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üìπ</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Source</span>
                    <span class="btn-status">@(CameraEnabled ? "ON" : "OFF")</span>
                </span>
            }
        </button>

        <!-- Audio Toggle Button -->
        <button class="btn @(AudioEnabled ? "btn-danger" : "btn-success")" disabled="@(IsAudioBusy)"
            aria-busy="@(IsAudioBusy)" @onclick="ToggleAudio"
            title="@(AudioEnabled ? "Disable audio feed" : "Enable audio feed")" @onmouseover="OnAudioMouseOver"
            @onmouseout="OnAudioMouseOut">
            @if (AudioHover)
            {
                @if (IsAudioBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üîä</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Audio Feed</span>
                    <span class="btn-status">@(AudioEnabled ? "Disable" : "Enable")</span>
                </span>
            }
            else
            {
                @if (IsAudioBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üîä</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Audio Feed</span>
                    <span class="btn-status">@(AudioEnabled ? "ON" : "OFF")</span>
                </span>
            }
        </button>

        <!-- Mix Processing Toggle Button -->
        <button class="btn @(MixProcessingEnabled ? "btn-danger" : "btn-success")" disabled="@(IsMixProcessingBusy)"
            aria-busy="@(IsMixProcessingBusy)" @onclick="ToggleMixProcessing"
            title="@(MixProcessingEnabled ? "Disable mix processing (video+audio combination)" : "Enable mix processing for video+audio stream")"
            @onmouseover="OnMixProcessingMouseOver" @onmouseout="OnMixProcessingMouseOut">
            @if (MixProcessingHover)
            {
                @if (IsMixProcessingBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üé¨</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Mix Processing</span>
                    <span class="btn-status">@(MixProcessingEnabled ? "Disable" : "Enable")</span>
                </span>
            }
            else
            {
                @if (IsMixProcessingBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üé¨</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Mix Processing</span>
                    <span class="btn-status">@(MixProcessingEnabled ? "ON" : "OFF")</span>
                </span>
            }
        </button>


        <!-- Go Live / Stop Live Button -->
        <button class="btn @(IsLive ? "btn-danger" : "btn-success")" @onclick="ToggleLiveClicked"
            disabled="@(IsLiveBusy || (!IsLive && (!IsStreamPlaying || IsGoingLive)))"
            aria-busy="@(IsLiveBusy || IsGoingLive)" @onmouseover="OnLiveMouseOver" @onmouseout="OnLiveMouseOut">
            @if (IsGoingLive)
            {
                <span class="spinner"></span>
                <span class="btn-label">
                    <span class="btn-title">Stream</span>
                    <span class="btn-status">Going Live...</span>
                </span>
            }
            else if (IsLiveBusy)
            {
                <span class="spinner"></span>
                <span class="btn-label">
                    <span class="btn-title">Stream</span>
                    <span class="btn-status">@(IsLive ? "Stop" : "Start")</span>
                </span>
            }
            else if (IsLive)
            {
                <span class="pulse-dot"></span>
                @if (LiveHover)
                {
                    @if (IsLiveBusy)
                    {
                        <span class="spinner"></span>
                    }
                    else
                    {
                        <span class="icon">üî¥</span>
                    }
                    <span class="btn-label">
                        <span class="btn-title">Stream</span>
                        <span class="btn-status">Stop</span>
                    </span>
                }
                else
                {
                    <span class="icon">üî¥</span>
                    <span class="btn-label">
                        <span class="btn-title">Stream</span>
                        <span class="btn-status">On Air</span>
                    </span>
                }
            }
            else
            {
                @if (LiveHover)
                {
                    @if (IsLiveBusy)
                    {
                        <span class="spinner"></span>
                    }
                    else
                    {
                        <span class="icon">üõú</span>
                    }
                    <span class="btn-label">
                        <span class="btn-title">Stream</span>
                        <span class="btn-status">Start</span>
                    </span>
                }
                else
                {
                    <span class="icon">üõú</span>
                    <span class="btn-label">
                        <span class="btn-title">Stream</span>
                        <span class="btn-status">Off Air</span>
                    </span>
                }
            }
        </button>

        <!-- Auto Broadcast Toggle Button -->
        <button class="btn @(AutoBroadcastEnabled ? "btn-danger" : "btn-success")" disabled="@(IsAutoBroadcastBusy)"
            aria-busy="@(IsAutoBroadcastBusy)" @onclick="ToggleAutoBroadcast"
            title="@(AutoBroadcastEnabled ? "Disable auto-broadcast" : "Enable auto-broadcast on print start")"
            @onmouseover="OnAutoBroadcastMouseOver" @onmouseout="OnAutoBroadcastMouseOut">
            @if (AutoBroadcastHover)
            {
                @if (IsAutoBroadcastBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üî¥</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Auto-Broadcast</span>
                    <span class="btn-status">@(AutoBroadcastEnabled ? "Disable" : "Enable")</span>
                </span>
            }
            else
            {
                <span class="icon">üî¥</span>
                <span class="btn-label">
                    <span class="btn-title">Auto-Broadcast</span>
                    <span class="btn-status">@(AutoBroadcastEnabled ? "ON" : "OFF")</span>
                </span>
            }
        </button>

        <!-- Auto Upload Toggle Button -->
        <button class="btn @(AutoUploadEnabled ? "btn-danger" : "btn-success")" disabled="@(IsAutoUploadBusy)"
            aria-busy="@(IsAutoUploadBusy)" @onclick="ToggleAutoUpload"
            title="@(AutoUploadEnabled ? "Disable auto-upload" : "Enable auto-upload timelapses to YouTube")"
            @onmouseover="OnAutoUploadMouseOver" @onmouseout="OnAutoUploadMouseOut">
            @if (AutoUploadHover)
            {
                @if (IsAutoUploadBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üïù</span>
                }
                <span class="btn-label">
                    <span class="btn-title">Upload Timelapses</span>
                    <span class="btn-status">@(AutoUploadEnabled ? "Disable" : "Enable")</span>
                </span>
            }
            else
            {
                <span class="icon">üïù</span>
                <span class="btn-label">
                    <span class="btn-title">Upload Timelapses</span>
                    <span class="btn-status">@(AutoUploadEnabled ? "ON" : "OFF")</span>
                </span>
            }
        </button>

        <!-- End Stream After Print Toggle Button -->
        <button class="btn @(EndStreamAfterPrintEnabled ? "btn-danger" : "btn-success")"
            disabled="@(IsEndAfterPrintBusy)" aria-busy="@(IsEndAfterPrintBusy)" @onclick="ToggleEndStreamAfterPrint"
            title="@(EndStreamAfterPrintEnabled ? "Disable end stream after print" : "Enable end stream after print completes")"
            @onmouseover="OnEndStreamAfterPrintMouseOver" @onmouseout="OnEndStreamAfterPrintMouseOut">
            @if (EndStreamAfterPrintHover)
            {
                @if (IsEndAfterPrintBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">‚èπÔ∏è</span>
                }
                <span class="btn-label">
                    <span class="btn-title">End After Print</span>
                    <span class="btn-status">@(EndStreamAfterPrintEnabled ? "Disable" : "Enable")</span>
                </span>
            }
            else
            {
                <span class="icon">‚èπÔ∏è</span>
                <span class="btn-label">
                    <span class="btn-title">End After Print</span>
                    <span class="btn-status">@(EndStreamAfterPrintEnabled ? "ON" : "OFF")</span>
                </span>
            }
        </button>

        <!-- End Stream After Song Button -->
        <button class="btn @(EndStreamAfterSongEnabled ? "btn-danger" : "btn-success")"
            @onclick="ToggleEndStreamAfterSong"
            title="@(EndStreamAfterSongEnabled ? "Cancel end after song" : "End stream gracefully after current song finishes")"
            @onmouseover="OnEndStreamAfterSongMouseOver" @onmouseout="OnEndStreamAfterSongMouseOut"
            disabled="@(IsEndAfterSongBusy || !IsLive)" aria-busy="@(IsEndAfterSongBusy)">
            @if (EndStreamAfterSongHover)
            {
                @if (IsEndAfterSongBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üéµ</span>
                }
                <span class="btn-label">
                    <span class="btn-title">End After Song</span>
                    <span class="btn-status">@(EndStreamAfterSongEnabled ? "Cancel" : "Enable")</span>
                </span>
            }
            else
            {
                @if (IsEndAfterSongBusy)
                {
                    <span class="spinner"></span>
                }
                else
                {
                    <span class="icon">üéµ</span>
                }
                <span class="btn-label">
                    <span class="btn-title">End After Song</span>
                    <span class="btn-status">@(EndStreamAfterSongEnabled ? "Pending" : "OFF")</span>
                </span>
            }
        </button>

    </div>

    <!-- Status Message -->
    @if (!string.IsNullOrEmpty(StatusMessage))
    {
        <div class="status-message">
            <span style="color:#66ccff">@StatusMessage</span>
        </div>
    }

    <!-- Broadcast URL -->
    @if (!string.IsNullOrEmpty(BroadcastId))
    {
        <div class="broadcast-url">
            <strong>Live URL:</strong>
            <a href="@($"https://www.youtube.com/watch?v={BroadcastId}")" target="_blank"
                style="color:#66ccff;text-decoration:underline">
                @($"https://www.youtube.com/watch?v={BroadcastId}")
            </a>
        </div>

        <!-- Privacy Control -->
        <div class="privacy-control">
            <label for="privacy-select" style="margin-right:8px;font-weight:600">Privacy:</label>
            <select id="privacy-select" @bind="SelectedPrivacy" @bind:after="OnPrivacyChanged" class="privacy-dropdown"
                disabled="@IsUpdatingPrivacy">
                <option value="public">Public</option>
                <option value="unlisted">Unlisted</option>
                <option value="private">Private</option>
            </select>
            @if (IsUpdatingPrivacy)
            {
                <span class="privacy-spinner"></span>
            }
        </div>
    }
</div>

<style>
    .control-panel {
        margin-top: 2rem;
        margin-bottom: 2rem;
        display: flex;
        flex-direction: column;
        gap: 12px;
        /* center the control panel horizontally within its container */
        align-items: center;
    }

    .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        /* ensure the button group is centered when it doesn't span full width */
        justify-content: center;
    }

    .btn {
        /* set a fixed width for all control buttons to prevent layout shift */
        --control-btn-width: 12rem;
        /* adjustable: change this value to tweak width */
        width: var(--control-btn-width);
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        font-size: 0.95em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        justify-content: center;
        /* center icon + label inside fixed-width button */
        /* base background can be overridden per-state via --btn-bg */
        background: var(--btn-bg, #555);
        color: #fff;
        -webkit-appearance: none;
        /* prevent platform-native blue on some browsers */
        appearance: none;
        -webkit-tap-highlight-color: transparent;
        /* mobile tap highlight */
    }

    /* highlight on hover without moving the button
       show the opposite (toggle) color as an outer glow to indicate the action */
    .btn:hover:not(:disabled) {
        filter: none;
        transform: none;
        /* ensure base color stays visible */
        background: var(--btn-bg) !important;
        color: #fff !important;
        -webkit-tap-highlight-color: transparent;
        /* much stronger, wider glow using the button's own glow color */
        box-shadow: 0 24px 80px rgba(0, 0, 0, 0.36), 0 0 64px var(--btn-glow, rgba(255, 255, 255, 0.22));
        /* add a subtle colored ring to make the highlight obvious */
        border: 2px solid rgba(255, 255, 255, 0.04);
        outline: 0;
    }

    /* keyboard focus styling */
    /* keep keyboard focus indicator but prevent browser default blue for mouse focus */
    .btn:focus {
        outline: none;
    }

    .btn:focus-visible {
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.22), 0 0 18px var(--btn-glow, rgba(255, 255, 255, 0.10)) inset;
        outline: 3px solid var(--btn-glow, rgba(102, 204, 255, 0.20));
    }

    /* pressed/depress animation */
    .btn:active:not(:disabled) {
        transform: translateY(2px) scale(0.995);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35) inset, 0 2px 6px rgba(0, 0, 0, 0.25);
        transition: transform 80ms ease, box-shadow 80ms ease;
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .btn-success {
        --btn-bg: #28a745;
        /* glow uses the same hue as the button (green) - increased alpha for visibility */
        --btn-glow: rgba(40, 167, 69, 0.48);
        background: var(--btn-bg);
    }

    .btn-danger {
        --btn-bg: #dc3545;
        /* glow uses the same hue as the button (red) - increased alpha for visibility */
        --btn-glow: rgba(220, 53, 69, 0.48);
        background: var(--btn-bg);
    }

    .icon {
        font-size: 1.5em;
    }

    /* Two-line label: title above status */
    .btn-label {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-width: 8ch;
        /* reserve enough space for longer labels */
        max-width: 18ch;
        line-height: 1.05;
    }

    .btn-title {
        font-size: 0.85em;
        opacity: 0.9;
        margin-bottom: 2px;
    }

    .btn-status {
        font-size: 1.05em;
        font-weight: 800;
        line-height: 1;
    }

    .pulse-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        background: #fff;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
    }

    @@keyframes pulse {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.3;
        }
    }

    .spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid #fff;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }

    @@keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .status-message,
    .broadcast-url {
        padding: 8px 0;
    }

    .privacy-control {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 0;
    }

    .privacy-dropdown {
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid #555;
        background: #2a2a2a;
        color: #fff;
        font-size: 0.95em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .privacy-dropdown:hover:not(:disabled) {
        border-color: #66ccff;
        box-shadow: 0 0 8px rgba(102, 204, 255, 0.3);
    }

    .privacy-dropdown:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .privacy-spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid #66ccff;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }
</style>

@code {
    [Parameter] public bool IsLive { get; set; }
    [Parameter] public bool IsStreamPlaying { get; set; }
    [Parameter] public bool IsGoingLive { get; set; }
    [Parameter] public bool StreamerRunning { get; set; }
    [Parameter] public bool WaitingForIngestion { get; set; }
    [Parameter] public bool CameraEnabled { get; set; }
    [Parameter] public bool AutoBroadcastEnabled { get; set; }
    [Parameter] public bool AutoUploadEnabled { get; set; }
    [Parameter] public bool EndStreamAfterPrintEnabled { get; set; }
    [Parameter] public bool EndStreamAfterSongEnabled { get; set; }
    [Parameter] public bool AudioEnabled { get; set; }
    [Parameter] public bool MixProcessingEnabled { get; set; }
    [Parameter] public string? BroadcastId { get; set; }
    [Parameter] public string? StatusMessage { get; set; }
    [Parameter] public string? CurrentPrivacy { get; set; }

    [Parameter] public EventCallback OnGoLive { get; set; }
    [Parameter] public EventCallback OnStopLive { get; set; }
    [Parameter] public EventCallback OnToggleCamera { get; set; }
    [Parameter] public EventCallback<bool> OnAutoUploadChanged { get; set; }
    [Parameter] public EventCallback<bool> OnAutoBroadcastChanged { get; set; }
    [Parameter] public EventCallback<bool> OnEndStreamAfterPrintChanged { get; set; }
    [Parameter] public EventCallback<bool> OnEndStreamAfterSongChanged { get; set; }
    [Parameter] public EventCallback<bool> OnAudioChanged { get; set; }
    [Parameter] public EventCallback<bool> OnMixProcessingChanged { get; set; }

    private bool CameraHover = false;
    private bool LiveHover = false;
    private bool AutoBroadcastHover = false;
    private bool AutoUploadHover = false;
    private bool EndStreamAfterPrintHover = false;
    private bool EndStreamAfterSongHover = false;
    private bool AudioHover = false;
    private bool MixProcessingHover = false;

    private string SelectedPrivacy = "unlisted";
    private bool IsUpdatingPrivacy = false;
    private string? LastBroadcastId = null;
    private bool IsCameraBusy = false;
    private bool IsAudioBusy = false;
    private bool IsLiveBusy = false;
    private bool IsAutoBroadcastBusy = false;
    private bool IsAutoUploadBusy = false;
    private bool IsEndAfterPrintBusy = false;
    private bool IsEndAfterSongBusy = false;
    private bool IsMixProcessingBusy = false;

    private void OnCameraMouseOver() => CameraHover = true;
    private void OnCameraMouseOut() => CameraHover = false;
    private void OnLiveMouseOver() => LiveHover = true;
    private void OnLiveMouseOut() => LiveHover = false;
    private void OnAutoBroadcastMouseOver() => AutoBroadcastHover = true;
    private void OnAutoBroadcastMouseOut() => AutoBroadcastHover = false;
    private void OnAutoUploadMouseOver() => AutoUploadHover = true;
    private void OnAutoUploadMouseOut() => AutoUploadHover = false;
    private void OnEndStreamAfterPrintMouseOver() => EndStreamAfterPrintHover = true;
    private void OnEndStreamAfterPrintMouseOut() => EndStreamAfterPrintHover = false;
    private void OnEndStreamAfterSongMouseOver() => EndStreamAfterSongHover = true;
    private void OnEndStreamAfterSongMouseOut() => EndStreamAfterSongHover = false;
    private void OnAudioMouseOver() => AudioHover = true;
    private void OnAudioMouseOut() => AudioHover = false;
    private void OnMixProcessingMouseOver() => MixProcessingHover = true;
    private void OnMixProcessingMouseOut() => MixProcessingHover = false;

    protected override void OnParametersSet()
    {
        // Reset privacy selection when broadcast changes or update from current privacy
        if (BroadcastId != LastBroadcastId)
        {
            LastBroadcastId = BroadcastId;
            SelectedPrivacy = CurrentPrivacy ?? "unlisted";
        }
        else if (!string.IsNullOrWhiteSpace(CurrentPrivacy) && CurrentPrivacy != SelectedPrivacy && !IsUpdatingPrivacy)
        {
            // Update from server if it changed externally
            SelectedPrivacy = CurrentPrivacy;
        }
    }

    private async Task OnPrivacyChanged()
    {
        if (string.IsNullOrEmpty(BroadcastId) || IsUpdatingPrivacy)
            return;

        IsUpdatingPrivacy = true;
        StateHasChanged();

        try
        {
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var requestBody = new { privacy = SelectedPrivacy };
            var response = await client.PostAsJsonAsync("api/live/privacy", requestBody);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse>();

            if (result?.Success != true)
            {
                Logger.LogWarning("Failed to update privacy: {Error}", result?.Error ?? "unknown");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating privacy: {Message}", ex.Message);
        }
        finally
        {
            IsUpdatingPrivacy = false;
            StateHasChanged();
        }
    }

    private class ApiResponse
    {
        public bool Success { get; set; }
        public string? Error { get; set; }
    }

    private async Task ToggleAutoBroadcast()
    {
        if (IsAutoBroadcastBusy)
            return;

        IsAutoBroadcastBusy = true;
        StateHasChanged();
        try
        {
            var newValue = !AutoBroadcastEnabled;
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/config/auto-broadcast?enabled={newValue}", null);

            if (response.IsSuccessStatusCode)
            {
                await OnAutoBroadcastChanged.InvokeAsync(newValue);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling auto-broadcast: {Message}", ex.Message);
        }
        finally
        {
            IsAutoBroadcastBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleAutoUpload()
    {
        if (IsAutoUploadBusy)
            return;

        IsAutoUploadBusy = true;
        StateHasChanged();
        try
        {
            var newValue = !AutoUploadEnabled;
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/config/auto-upload?enabled={newValue}", null);

            if (response.IsSuccessStatusCode)
            {
                await OnAutoUploadChanged.InvokeAsync(newValue);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling auto-upload: {Message}", ex.Message);
        }
        finally
        {
            IsAutoUploadBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleEndStreamAfterPrint()
    {
        if (IsEndAfterPrintBusy)
            return;

        IsEndAfterPrintBusy = true;
        StateHasChanged();
        try
        {
            var newValue = !EndStreamAfterPrintEnabled;
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/config/end-stream-after-print?enabled={newValue}", null);

            if (response.IsSuccessStatusCode)
            {
                await OnEndStreamAfterPrintChanged.InvokeAsync(newValue);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling end-stream-after-print: {Message}", ex.Message);
        }
        finally
        {
            IsEndAfterPrintBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleEndStreamAfterSong()
    {
        if (IsEndAfterSongBusy)
            return;

        IsEndAfterSongBusy = true;
        StateHasChanged();
        try
        {
            var newValue = !EndStreamAfterSongEnabled;
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/stream/end-after-song?enabled={newValue}", null);

            if (response.IsSuccessStatusCode)
            {
                await OnEndStreamAfterSongChanged.InvokeAsync(newValue);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling end-stream-after-song: {Message}", ex.Message);
        }
        finally
        {
            IsEndAfterSongBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleAudio()
    {
        if (IsAudioBusy)
            return;

        IsAudioBusy = true;
        StateHasChanged();
        try
        {
            var newValue = !AudioEnabled;
            using var client = new HttpClient { BaseAddress = new Uri(Nav.BaseUri) };
            var response = await client.PostAsync($"api/audio/enabled?enabled={newValue}", null);
            if (response.IsSuccessStatusCode)
            {
                await OnAudioChanged.InvokeAsync(newValue);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling audio feed: {Message}", ex.Message);
        }
        finally
        {
            IsAudioBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleCameraClicked()
    {
        if (IsCameraBusy)
            return;

        IsCameraBusy = true;
        StateHasChanged();
        try
        {
            await OnToggleCamera.InvokeAsync((object?)null);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error invoking camera toggle: {Message}", ex.Message);
        }
        finally
        {
            IsCameraBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleLiveClicked()
    {
        if (IsLiveBusy)
            return;

        IsLiveBusy = true;
        StateHasChanged();
        try
        {
            if (IsLive)
            {
                await OnStopLive.InvokeAsync((object?)null);
            }
            else
            {
                await OnGoLive.InvokeAsync((object?)null);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling live: {Message}", ex.Message);
        }
        finally
        {
            IsLiveBusy = false;
            StateHasChanged();
        }
    }

    private async Task ToggleMixProcessing()
    {
        if (IsMixProcessingBusy)
            return;

        IsMixProcessingBusy = true;
        StateHasChanged();
        try
        {
            var newValue = !MixProcessingEnabled;
            await OnMixProcessingChanged.InvokeAsync(newValue);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling mix processing: {Message}", ex.Message);
        }
        finally
        {
            IsMixProcessingBusy = false;
            StateHasChanged();
        }
    }
}